{"pages":[{"title":"Jerome's Blog","text":"从CSDN搬家到GitHub啦！CSDN博客：https://blog.csdn.net/peter_819 我是谁?武汉大学计算机学院18级本科生，2020腾讯IEG研发效能部实习生，喜欢学学图形学，游戏引擎开发。 写点啥?时不时更新，写写图形学相关，我的JEngine开发相关，实习日常相关，碎碎念相关。没事的时候挖挖坑，立立flag之类的。 联系方式QQ:172163600WeChat:ghb15004698932知乎:JeromeG邮箱:peter_819@163.com 友链Yashem: https://me.csdn.net/qq_33330876","link":"/about/index.html"}],"posts":[{"title":"C++面试知识点","text":"C++面试知识点 C++ const修饰指针const int* p不可改变指针值int* const p不可改变p指向修饰引用：const string&amp; str修饰成员函数void func() const {} 不可改变成员变量（const ClassName *this） static修饰全局变量&amp;函数：限定在当前编译单元修饰局部变量：开在静态区，只初始化一次，可用域为当前范围修饰成员函数：不可访问非静态成员，只能用类名调用，没有this修饰成员变量：只能类名调用，在静态区。在main函数执行之前分配内存。 inline复制函数代码调用函数不压栈，直接映射参数&amp;返回值类声明中函数都是inline建议编译器inline，有循环递归switch的不inline乱用会代码膨胀，且修改后重新编译所有调用虚函数可以内联但是失去运行时多态，只能className a;a.test(); this非静态函数中，指向调用它的对象，不可赋值（ClassName* const this）属于非静态成员函数默认第一个参数，可以std::bind volatile编译器会自动优化如int a = 2;b=a+2;cout&lt;&lt;b;不将a写入内存直接当作2调用。如果在b=a+2;前 a被其他线程或某种原因修改则出错声明后禁止编译器编译优化，强制写入读出内存。可以修饰指针 const sizeof数组sizeof为数组空间大小指针sizeof为指针本身大小（一半为4） 内存对齐结构体中存在内存对齐，假设pragma pack设定值为p当前类型大小为q为当前变量开空间时遵循开头位置offset被min(p,q)整除总开辟空间遵循可以被max({q},p)整除如int a;char b;char c;占用8char a;int b;char c;占用12#prama pack()可以设置为1,2,4,8等位域：限制某类型变量只占用若干二进制位，int a:2; a只占用两个bit extern可以在其他编译单元使用，可以代替部分include的工作。extern “C”{ … } 在c++中调用c风格代码 explicit修饰构造函数或转换函数（重载括号运算）可以防止隐式转换 如ClassName c = 1;会隐式调用构造函数ClassName(int)(参数只有一个或其余均有默认值)explicit声明后只能显示ClassName c = ClassName(1); friend可以访问private，且单向。 usingusing namespace / using namespace::nameC++11中派生类using base::base;可以重用父类构造函数相当于derived(params) : base(args){}还可以相当于typedef 给模板别名template&lt; typename T&gt;using Ref = std::share_ptr&lt; T&gt;; decltype检查实体声明类型并使用int a;decltype(a) 为int 可以直接声明变量可以后置声明返回值类型template&lt; typename IT&gt;auto fcn(IT a) -&gt; decltype(a){} 左右值引用右值引用：字符串常量，临时对象等等移动语义：move() 传入左/右值 返回右值引用原理：引用折叠：除了&amp;&amp;+&amp;&amp;=&amp;&amp;其他均为&amp;传入模板函数中的左值T自带一个&amp;精确传递：解决传入函数参数推测类型默认为左值问题 描述不太清楚 define一对一转换参数#define test(type) #type ：将type字面转为字符串##：连接两个字面值 多态编译期多态：函数&amp;运算符重载 ， 模板运行期多态：虚函数， 类型转换（dynamic_cast）RTTI 虚函数虚函数表：生成对象时产生，继承时继承父类虚函数表指针有虚函数的空类大小为4(vfptr) 无虚函数空类大小为1重写时覆盖虚函数表的函数指针构造函数不能虚函数：调用构造函数时没有虚表指针虚析构函数：被继承时一定虚析构，防止泄露纯虚函数：抽象类 虚继承/多继承防止菱形继承内存重复，采用虚表，继承时继承多个父类的虚表指针虚表存储虚基类内存偏移量 描述不清 内存分配new/delete:自动调用构造/析构函数，在堆区开内存，失败返回badalloc定位new new(p) int(2);在p指针位置开内存 其实就是返回int类型的pmalloc/free:不调用构造/析构，失败返回null，开内存位置不同于new *不清楚**对象内存限制：只能开在堆上：私有析构函数（在栈中开时会检测构造/析构函数）只能开在栈上：私有重载new&amp;delete 智能指针shared_ptr: 可以多个指向同一对象，有引用计数，计数归零析构对象delete 实现unique_ptr: 不可以多个指向同一对象，不可以赋值，可以右值赋值（move）赋值后销除原指针weak_ptr: 解决share_ptr死锁问题：两个资源相互引用，无法同时析构。相当于shared_ptr的容器，不增加引用计数，通过lock获得原share指针auto_ptr:可以赋值操作的unique 原标准中，C++11弃用 类型转换const_cast: 可以删除原对象const/volatile属性reinterpret_cast: 重新解释二进制数据，最强制转换，慎用static_cast: 基本同c中显式转换，可以父类-&gt;子类 （不安全）dynamic_cast: RTTI 运行时类型信息，可以父类转子类自动检测是否可以转换（仅支持有虚函数表的类） RTTI相关typeid 返回type_info 运行时对象类型type_info对象中保存的类型信息 lambda表达式[=]：接受所有值，按值[&amp;]：接受所有值，按引用[a]：接受a，按值[&amp;a]：接受a，按引用[&amp;,a]：接受a按值，接受其他所有按引用[=,&amp;a]：接受a按引用，接受其他所有按值[a] ( ) mutable {a++;} 按值接受a拷贝 修改a拷贝a值不变[ ] ( )-&gt;int{return 1;} 返回值类型int 链接库 静态链接：浪费内存空间，每个可执行程序对目标文件都要副本，一个模块更新需要重新编译。 动态链接：将对符号的重定位推迟到运行时，解决静态库的两个缺点。","link":"/2020/05/03/Intership-CPP/"},{"title":"图形学面试知识点","text":"图形学面试知识点 图形学 渲染管线顶点数据输入 (Vertices)顶点着色器 (Vertex Shader)曲面细分着色器 (Tessellation Shader)几何着色器 (Geometry Shader)图元装配 (Primitive Setup)裁剪剔除 (Culling and Clipping)屏幕映射 (Screen Mapping)光栅化 (Rasterization)片段着色器 (Fragment Shader)混合测试 (Blending and Testing) 顶点数据顶点坐标，顶点纹理，顶点法线，顶点颜色等顶点缓存(Vertex Buffer)，索引缓存 (Index Buffer) 顶点着色器输入顶点数据 坐标变换：(*为顶点着色器中) 局部坐标 (Local Coor)| 模型矩阵 Model *世界坐标 (World Coor)| 观察矩阵View *观察坐标 (View Coor)| 投影矩阵Projection *裁剪坐标 (Clip Coor)| 透视除法标准设备空间 NDC (Normalized Device Coor)| 视口变换窗口坐标 + 法线变换 * 平移不变，旋转乘渲染矩阵，非均匀缩放 （矩阵逆变换） + 投影 * 透视投影 (Projective Projection) : 视锥体 (Frustum): znear,zfar,视角FOV(Field of View),屏幕纵横比(Aspect Ratio) * 正交投影 (Orthographic Projection) : 正方体 + 着色 * 平面着色 (Flat Shading) : 三角形第一个点标识颜色 * 高洛德着色 (Gouraud Shader) : 顶点着色器中计算顶点颜色，光栅化插值颜色 * 冯氏着色 (Phong Shading) : 光栅化插值法线，片元着色器中计算颜色 曲面细分着色器 (Tessellation Shader) 几何着色器 (Geometry Shader) 图元装配 向顶点装入DrawCall指定的图元 裁剪 背面剔除删除背对摄像机的图元，法向量判断，三点顺时针剔除，逆时针保留（右手定则）可以设置剔除方向back/front 屏幕映射 (Screen Mapping) 透视除法：点坐标为齐次坐标，经过透视矩阵变换后w值不为1，将xyz除以w以达到近大远小 视口变换：将NDC坐标转换为窗口坐标，将z坐标映射到[-1,1]（OpenGL）， glViewport() 设定视口坐标&amp;宽高 拾取 光栅化 线段光栅化： 数字微分画线 DDA(Digital Differential Analyzer) : 取增量x判断y，有浮点运算 Bresenham ：没有浮点数运算，d = Δx(b-a) 判断d 片段着色器 (Fragment Shader) 光照模型 Phong : 计算高光：光源向量关于法线反射向量计算（不连续，大于90度为负） Blinn-Phone：计算高光：光源向量+视角向量计算 （连续） 纹理 法线贴图 锯齿和抗锯齿 (Aliasing and Anti-aliasing) 阴影 阴影贴图 测试 裁切测试 Alpha测试 深度测试 模板测试 混合 Alpha混合 场景管理 BSP树 四叉树八叉树 k-d树 延迟渲染 前向渲染 (defer / forward) 延迟渲染优点：对于多光源场景效率更优 延迟渲染缺点：不能用硬件抗锯齿，不能渲染透明体，GPU带宽占用高（手游不常用） 实现方法：前向渲染中光照在fragment shader中计算，延迟渲染将光照只在最后显示出的像素上计算，将原来计算光照的数据如法线，颜色，坐标，高光等存入G-buffer，在进行z-test后另行渲染光照，对每个最终显示的像素计算光照信息。 OpenGL实现 纹理 纹理环绕 GL_REPEAT ：重复 GL_MIRRORED_REPEAT ：镜像重复 GL_CLAMP_TO_EDGE ：边缘拉伸 GL_CLAMP_TO_BORDER ：边缘指定颜色 纹理过滤：将纹理坐标浮点值映射到像素 GL_NEAREST ：取最近邻的像素颜色 GL_LINEAR ：根据相邻像素颜色插值 MipMap","link":"/2020/05/03/Intership-CG/"},{"title":"JEngine架构v1.0","text":"","link":"/2020/03/13/JEngine-Architecture-v1-0/"},{"title":"Windows API链接GLAD绘制OpenGL","text":"在使用win32 API进行编写windows窗口时，需要链接GLAD的OpenGL内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445HWND m_hwnd;HDC m_dc;HGLRC m_rc;void WinApiGLContext::Init() { PIXELFORMATDESCRIPTOR pfd = { sizeof(PIXELFORMATDESCRIPTOR), // size of this pfd 1, // version number PFD_DRAW_TO_WINDOW | // support window PFD_SUPPORT_OPENGL | // support OpenGL PFD_DOUBLEBUFFER, // double buffered PFD_TYPE_RGBA, // RGBA type 24, // 24-bit color depth 0, 0, 0, 0, 0, 0, // color bits ignored 0, // no alpha buffer 0, // shift bit ignored 0, // no accumulation buffer 0, 0, 0, 0, // accum bits ignored 32, // 32-bit z-buffer 0, // no stencil buffer 0, // no auxiliary buffer PFD_MAIN_PLANE, // main layer 0, // reserved 0, 0, 0 // layer masks ignored }; m_dc = GetDC(m_hwnd); int pf = ChoosePixelFormat(m_dc, &amp;pfd); SetPixelFormat(m_dc, pf, &amp;pfd); m_rc = wglCreateContext(m_dc); wglMakeCurrent(m_dc, m_rc); gladLoadGL(); JE_CORE_INFO(&quot;OpenGL Vendor: {0}&quot;, glGetString(GL_VENDOR)); JE_CORE_INFO(&quot;OpenGL Renderer: {0}&quot;, glGetString(GL_RENDERER)); JE_CORE_INFO(&quot;OpenGL version: {0}&quot;, glGetString(GL_VERSION));}void WinApiGLContext::SwapBuffer() { SwapBuffers(m_dc);} 注：一定要记得渲染之前设置glViewport，因为GLFW好像是默认设置viewport，我迁移到winAPI之后才发现我忘记了TAT","link":"/2020/05/04/JEngine-Win32-GLAD-tutorial/"},{"title":"C#大作业1-分组","text":"UI界面+贴图素材+关卡设计 2人主要写一下进入游戏的UI系统UI可能包括：登录，创建房间，开始游戏，游戏暂停结束等关卡设计可能有：找各种贴图纹理素材，关卡的设计（要好看） 网络编程 2人主要写一下联网部分，实现一下多人在线可能要写：socket之类的网络编程，没准还得写点服务端 游戏逻辑 2人主要写人物控制，武器系统，伤害系统等等可能要写：人物控制类：操作逻辑，武器类：各种不同功能武器，伤害系统：伤害计算 分数计算后续可能写点机关？","link":"/2020/05/07/dev-UnityGame-1/"},{"title":"C#大作业2-网络交互","text":"Abuse Of Heart 游戏网络交互模块简介 &amp; 开发须知 简介 原理 采用TCP/UDP协议传输数据包，将用户操作信号传递到服务端，服务端将物体移动信息发送给客户端 实现 初步实现了TCP/UDP数据包传输 实现了客户端登录过程：客户端connect-&gt;服务端发送welcome-&gt;客户端接受，回复welcomeReceive-&gt;服务端接受 实现了客户端操作信号发送：客户端捕获用户键盘输入发送给服务端-&gt;服务端接受信号，处理角色移动-&gt;服务端发送角色位置旋转信息-&gt;客户端接收并调用Unity接口 TODO： 需要实现投掷物——在服务端创建物体 开发须知 代码结构简介 服务端： Server：处理用户连接，为连接进来的用户分配Client逻辑（只需增减packetHandle目录） Client：TCP/UDP实现，处理数据交换（无需改动） ServerHandle：处理服务端收到的信号的函数（增添类似函数需要在Server中更改目录，Packet中改Enum） ServerSend：向客户端发送数据的函数（增添类似的函数即可发送不同数据，需要Packet中改Enum） Packet：发送的数据包类，封装了主要数据类型，以及Vector3,Quaternion（增减Handle与Send函数需要改动代码开头Enum） Constants：常量，包含每秒Tick次数，当前为30，需要与Unity中ProjectSetting相同 其他：无需更改 客户端： Client：同服务端，TCP/UDP实现，处理数据交换（需要增减packetHandle目录） ClientHandle：同服务端（增添类似函数需要在Server中更改目录） ClientSend：同服务端（packet中改Enum） Packet：同服务端（一定确保服务端与客户端代码完全一致） PlayerController：处理用户输入信号传递给服务端 GameManager：负责生成/移除对象 PlayerManager：用户信息 UIManager：登录界面UI CameraController：没有diao用 需要删除 如何开发 谁知道呢？我就写了这么多，剩下的代码注释写了一些 初步的就增加一下Handle和Send函数 所有都在服务端处理吧 代码 AOH-Client Git目录：https://code.aliyun.com/jeromeg/AOH-Client/tree/master AOH-Server Git目录：https://code.aliyun.com/jeromeg/AOH-Server/tree/master AOH-Asset Git目录： https://code.aliyun.com/jeromeg/AOH-Asset 配置 Unity相关的配置一句两句说不清，需要配置的时候在群里交流 编译 Unity 项目设置(Project Setting)中刷新时间设置成0.33333 Server端编译选项选择 Server mode 调试 本地调试时在Unity客户端的Client对象里把ip设置成127.0.0.1 服务器调试时把这个ip改成服务器的ip，保证没有防火墙屏蔽端口（可以将端口添加进防火墙）","link":"/2020/05/15/dev-UnityGame-2/"}],"tags":[{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面试经验","slug":"面试经验","link":"/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"面试知识点","slug":"面试知识点","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"JEngine","slug":"JEngine","link":"/tags/JEngine/"},{"name":"游戏引擎","slug":"游戏引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"CsharpWork","slug":"CsharpWork","link":"/tags/CsharpWork/"}],"categories":[{"name":"Internship","slug":"Internship","link":"/categories/Internship/"},{"name":"JEngine","slug":"JEngine","link":"/categories/JEngine/"},{"name":"Development","slug":"Development","link":"/categories/Development/"}]}