{"pages":[{"title":"Jerome's Blog","text":"从CSDN搬家到GitHub啦！CSDN博客：https://blog.csdn.net/peter_819 我是谁?武汉大学计算机学院18级本科生，2020腾讯IEG研发效能部实习生，喜欢学学图形学，游戏引擎开发。 写点啥?时不时更新，写写图形学相关，我的JEngine开发相关，实习日常相关，碎碎念相关。没事的时候挖挖坑，立立flag之类的。 联系方式QQ:172163600WeChat:ghb15004698932知乎:JeromeG邮箱:peter_819@163.com 友链Yashem: https://me.csdn.net/qq_33330876","link":"/about/index.html"},{"title":"Classified","text":"RHI_GLES","link":"/Classified/index.html"},{"title":"Internship-NextEngine-RHIopengl-1","text":"??? RHIPlatformHandle? ConstBuffer bind? Dynamic VBO? Render Pass? RHI/Implement/GLES3 GLES3Buffer ConstBuffer VertexBuffer IndexBuffer GLES3ConstantBuffer 传给shader的uniform buffer 不太明白这个dynamic buffer的区别和实现 GLES3Context 还没看，应该就是设置渲染内容参数和swapbuffer GLES3Device 方法大集合 GLES3FrameBuffer 管理渲染缓存，默认是渲染到屏幕，绑定其他是离屏渲染 GLES3GpuPrograms 不知道 : TODO GLES3Pipeline 设置blend,rasterization,stencil&amp;depth参数，绘制前延迟应用设置 GLES3Program 创建，应用Program，AttachShader。 GLES3RenderPass 处理rendertarget，离屏渲染相关，实现没看懂 GLES3Sample 各种纹理采样参数设置 GLES3Shader 还没看 : TODO GLES3Texture 还没看 : TODO GLES3VBO VBO对象，绑定Vertex/Index Buffer 负责绘制等操作 dynamicVBO 不知道 : TODO GLES3Window 还没看 :TODO //总之还是各种类的OpenGL实现，实现并不难懂，但是上层抽象太多了，需要往上层看看。","link":"/Classified/Internship-NextEngine-RHIopengl-1.html"}],"posts":[{"title":"Internship-Diary-3&4","text":"周末划水日记 周六看了一点点数据库的东西准备考试，一整天都没搞实习这边的事情。NE这边居然好像不用996，具体还不怎么清楚…. 周日下午看了会NE的代码，RHI的OpenGL实现这块，只是看了看buffer和一半的Pipeline。碰到几个看不懂的地方写在不发的博客里了。这个OpenGL的实现基本也就是JEngine的++++版，具体实现看的还比较清楚，只是他的架构层数太多了，需要后续理解。buffer的位置写了uniform block实现，这个我还没写过，查了查博客大概明白了。基本就是多个shader绑定几个block，然后每次get到block的index绑定数据，赋值的时候再查一下变量的offset。记得要bindbufferbase。具体的找时间写个博客记录下吧。 他们在群里也发了一遍我之前收藏的那个ECS实现，挺有意思的，一定要康康。挂一个知乎链接5.17号了都，得搞搞学校考试得东西了…头大…","link":"/2020/05/17/Internship-Diary-3-4/"},{"title":"JEngine架构v1.0","text":"","link":"/2020/03/13/JEngine-Architecture-v1-0/"},{"title":"Windows API链接GLAD绘制OpenGL","text":"在使用win32 API进行编写windows窗口时，需要链接GLAD的OpenGL内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445HWND m_hwnd;HDC m_dc;HGLRC m_rc;void WinApiGLContext::Init() { PIXELFORMATDESCRIPTOR pfd = { sizeof(PIXELFORMATDESCRIPTOR), // size of this pfd 1, // version number PFD_DRAW_TO_WINDOW | // support window PFD_SUPPORT_OPENGL | // support OpenGL PFD_DOUBLEBUFFER, // double buffered PFD_TYPE_RGBA, // RGBA type 24, // 24-bit color depth 0, 0, 0, 0, 0, 0, // color bits ignored 0, // no alpha buffer 0, // shift bit ignored 0, // no accumulation buffer 0, 0, 0, 0, // accum bits ignored 32, // 32-bit z-buffer 0, // no stencil buffer 0, // no auxiliary buffer PFD_MAIN_PLANE, // main layer 0, // reserved 0, 0, 0 // layer masks ignored }; m_dc = GetDC(m_hwnd); int pf = ChoosePixelFormat(m_dc, &amp;pfd); SetPixelFormat(m_dc, pf, &amp;pfd); m_rc = wglCreateContext(m_dc); wglMakeCurrent(m_dc, m_rc); gladLoadGL(); JE_CORE_INFO(&quot;OpenGL Vendor: {0}&quot;, glGetString(GL_VENDOR)); JE_CORE_INFO(&quot;OpenGL Renderer: {0}&quot;, glGetString(GL_RENDERER)); JE_CORE_INFO(&quot;OpenGL version: {0}&quot;, glGetString(GL_VERSION));}void WinApiGLContext::SwapBuffer() { SwapBuffers(m_dc);} 注：一定要记得渲染之前设置glViewport，因为GLFW好像是默认设置viewport，我迁移到winAPI之后才发现我忘记了TAT","link":"/2020/05/04/JEngine-Win32-GLAD-tutorial/"},{"title":"C#大作业2-网络交互","text":"Abuse Of Heart 游戏网络交互模块简介 &amp; 开发须知 简介 原理 采用TCP/UDP协议传输数据包，将用户操作信号传递到服务端，服务端将物体移动信息发送给客户端 实现 初步实现了TCP/UDP数据包传输 实现了客户端登录过程：客户端connect-&gt;服务端发送welcome-&gt;客户端接受，回复welcomeReceive-&gt;服务端接受 实现了客户端操作信号发送：客户端捕获用户键盘输入发送给服务端-&gt;服务端接受信号，处理角色移动-&gt;服务端发送角色位置旋转信息-&gt;客户端接收并调用Unity接口 TODO： 需要实现投掷物——在服务端创建物体 开发须知 代码结构简介 服务端： Server：处理用户连接，为连接进来的用户分配Client逻辑（只需增减packetHandle目录） Client：TCP/UDP实现，处理数据交换（无需改动） ServerHandle：处理服务端收到的信号的函数（增添类似函数需要在Server中更改目录，Packet中改Enum） ServerSend：向客户端发送数据的函数（增添类似的函数即可发送不同数据，需要Packet中改Enum） Packet：发送的数据包类，封装了主要数据类型，以及Vector3,Quaternion（增减Handle与Send函数需要改动代码开头Enum） Constants：常量，包含每秒Tick次数，当前为30，需要与Unity中ProjectSetting相同 其他：无需更改 客户端： Client：同服务端，TCP/UDP实现，处理数据交换（需要增减packetHandle目录） ClientHandle：同服务端（增添类似函数需要在Server中更改目录） ClientSend：同服务端（packet中改Enum） Packet：同服务端（一定确保服务端与客户端代码完全一致） PlayerController：处理用户输入信号传递给服务端 GameManager：负责生成/移除对象 PlayerManager：用户信息 UIManager：登录界面UI CameraController：没有diao用 需要删除 如何开发 谁知道呢？我就写了这么多，剩下的代码注释写了一些 初步的就增加一下Handle和Send函数 所有都在服务端处理吧 代码 AOH-Client Git目录：https://code.aliyun.com/jeromeg/AOH-Client/tree/master AOH-Server Git目录：https://code.aliyun.com/jeromeg/AOH-Server/tree/master AOH-Asset Git目录： https://code.aliyun.com/jeromeg/AOH-Asset 配置 Unity相关的配置一句两句说不清，需要配置的时候在群里交流 编译 Unity 项目设置(Project Setting)中刷新时间设置成0.33333 Server端编译选项选择 Server mode 调试 本地调试时在Unity客户端的Client对象里把ip设置成127.0.0.1 服务器调试时把这个ip改成服务器的ip，保证没有防火墙屏蔽端口（可以将端口添加进防火墙）","link":"/2020/05/15/dev-UnityGame-2/"},{"title":"2020.4.15","text":"大概从2.3号开始说起吧，从打开youtube看到了那个openGL教程，从看知乎推荐下了一本《Real Time Rendering》，就开始了这两个月的故事。 明天面试腾讯和吉比特，这一周左右基本保持每天一次笔试/面试，不知道是累了还是皮了，既然不想学习就写一写记录吧。 从最开始youtube上看那个胖老哥讲opengl将近100期的教程，然后自己看RTR看了四五章，后来找到cherno的Hazel教程，跟着教程写了个框架，把胖老哥的opengl强行塞了进去玩了玩。到了三月二十看到llb问我要不要投实习，才算是一咬牙拿定了主意，一晚上投了网易互娱雷火吉比特。其实当时真的没抱希望，只是投着试试看，也没什么风险。 从20号到30号开始就搜搜面经，c++，图形学，看到什么学什么，面对面试题目学习，30号左右考了个雷火笔试，后来吉比特一直没声音，就索性多投两份，投了一个头条，投了一个完美，又过两天cbn聊的我心动了还是去投了一个腾讯日常实习。 截止到今天算是做完了所有的笔试，笔试并不难，可能只是作为筛选依据而不是标准吧。 腾讯那天突然给我发消息上午说下午电话面试，这个速度也是够快，下午打电话大概是一个意向面试吧，拿着简历问了问我的项目，问问c++基础，说我的意向非常符合他们的岗位，直接告诉我等下一轮的技术面。 至于雷火，笔试过了直接发了两次面试的时间，一面简单一点，那个老哥挺和蔼，写了个小代码，问点算法题目基础，二面老哥比较严格，不过也有点可爱，我没答上他提醒我，我接着他话说下去他说对，但是还得算你没答上哈哈。两次面试问了问我的学习方向，大概是没问题的，至于结果嘛，他说你这个基础还是不扎实，但是毕竟是相对于研究生说的，作为本科生很少有涉及这方面的。感觉是要收拒信了，等着吧。 从最开始的投着玩试试看，到后来搜面经的时候，其实已经逐渐转变想法了，一点点融入了这个过程，也更加希望自己能拿到一个offer，但是反过来看看我其实除了大二时间多一些，方向明确一些，还没什么竞争优势。这就是纠结的点吧，情感上非常想要offer，但是理性分析现实还是很残酷。 这么看起来求职这东西还是很摧残人的，回头看看这才过去两个多月，我感觉好像过了很久很久。。 希望最后最后能实现梦想吧，哪怕是秋招，明年春招，都可以。（现在说这个话还是有点丧了，毕竟希望还要有。还要继续冲） 接下去的话，大概这个月末，五一结束左右所有面试也应该差不多结束了，不管过不过，日子还得过。 这个月面试期间补一补计网和操作系统课，下个月开始补组合和数据库，然后赶紧学c#和unity，把这个大作业好好做，毕竟这也是未来的一部分。 这学期的课好好考争取能弄个3.7吧，然后闲的无聊的时候学学houdini玩。 真的是一个决定了就一条路走到南墙的人，从决定打OI开始好久没有做过这种选择了，从来没有怀疑过做这个到底是不是对的，我只觉得这就是我的以后QAQ","link":"/2020/05/03/Nothing-2020-4-15/"},{"title":"数据库系统-1","text":"数据库系统 数据库(DB) 数据库管理系统(DBMS) 数据库应用(DBAP) 数据库管理员(DBA) 计算机基本系统 数据库管理系统(DBMS) External Level Conceptual Level Internal Level 数据模型 (数据-&gt;模式-&gt;模型) 关系模型 - 表 层次模型 - 树 网状模型 - 图","link":"/2020/05/16/Learning-DB-1/"},{"title":"C#大作业1-分组","text":"UI界面+贴图素材+关卡设计 2人主要写一下进入游戏的UI系统UI可能包括：登录，创建房间，开始游戏，游戏暂停结束等关卡设计可能有：找各种贴图纹理素材，关卡的设计（要好看） 网络编程 2人主要写一下联网部分，实现一下多人在线可能要写：socket之类的网络编程，没准还得写点服务端 游戏逻辑 2人主要写人物控制，武器系统，伤害系统等等可能要写：人物控制类：操作逻辑，武器类：各种不同功能武器，伤害系统：伤害计算 分数计算后续可能写点机关？","link":"/2020/05/07/dev-UnityGame-1/"},{"title":"图形学面试知识点","text":"图形学面试知识点 图形学 渲染管线顶点数据输入 (Vertices)顶点着色器 (Vertex Shader)曲面细分着色器 (Tessellation Shader)几何着色器 (Geometry Shader)图元装配 (Primitive Setup)裁剪剔除 (Culling and Clipping)屏幕映射 (Screen Mapping)光栅化 (Rasterization)片段着色器 (Fragment Shader)混合测试 (Blending and Testing) 顶点数据顶点坐标，顶点纹理，顶点法线，顶点颜色等顶点缓存(Vertex Buffer)，索引缓存 (Index Buffer) 顶点着色器输入顶点数据 坐标变换：(*为顶点着色器中) 局部坐标 (Local Coor)| 模型矩阵 Model *世界坐标 (World Coor)| 观察矩阵View *观察坐标 (View Coor)| 投影矩阵Projection *裁剪坐标 (Clip Coor)| 透视除法标准设备空间 NDC (Normalized Device Coor)| 视口变换窗口坐标 + 法线变换 * 平移不变，旋转乘渲染矩阵，非均匀缩放 （矩阵逆变换） + 投影 * 透视投影 (Projective Projection) : 视锥体 (Frustum): znear,zfar,视角FOV(Field of View),屏幕纵横比(Aspect Ratio) * 正交投影 (Orthographic Projection) : 正方体 + 着色 * 平面着色 (Flat Shading) : 三角形第一个点标识颜色 * 高洛德着色 (Gouraud Shader) : 顶点着色器中计算顶点颜色，光栅化插值颜色 * 冯氏着色 (Phong Shading) : 光栅化插值法线，片元着色器中计算颜色 曲面细分着色器 (Tessellation Shader) 几何着色器 (Geometry Shader) 图元装配 向顶点装入DrawCall指定的图元 裁剪 背面剔除删除背对摄像机的图元，法向量判断，三点顺时针剔除，逆时针保留（右手定则）可以设置剔除方向back/front 屏幕映射 (Screen Mapping) 透视除法：点坐标为齐次坐标，经过透视矩阵变换后w值不为1，将xyz除以w以达到近大远小 视口变换：将NDC坐标转换为窗口坐标，将z坐标映射到[-1,1]（OpenGL）， glViewport() 设定视口坐标&amp;宽高 拾取 光栅化 线段光栅化： 数字微分画线 DDA(Digital Differential Analyzer) : 取增量x判断y，有浮点运算 Bresenham ：没有浮点数运算，d = Δx(b-a) 判断d 片段着色器 (Fragment Shader) 光照模型 Phong : 计算高光：光源向量关于法线反射向量计算（不连续，大于90度为负） Blinn-Phone：计算高光：光源向量+视角向量计算 （连续） 纹理 法线贴图 锯齿和抗锯齿 (Aliasing and Anti-aliasing) 阴影 阴影贴图 测试 裁切测试 Alpha测试 深度测试 模板测试 混合 Alpha混合 场景管理 BSP树 四叉树八叉树 k-d树 延迟渲染 前向渲染 (defer / forward) 延迟渲染优点：对于多光源场景效率更优 延迟渲染缺点：不能用硬件抗锯齿，不能渲染透明体，GPU带宽占用高（手游不常用） 实现方法：前向渲染中光照在fragment shader中计算，延迟渲染将光照只在最后显示出的像素上计算，将原来计算光照的数据如法线，颜色，坐标，高光等存入G-buffer，在进行z-test后另行渲染光照，对每个最终显示的像素计算光照信息。 OpenGL实现 纹理 纹理环绕 GL_REPEAT ：重复 GL_MIRRORED_REPEAT ：镜像重复 GL_CLAMP_TO_EDGE ：边缘拉伸 GL_CLAMP_TO_BORDER ：边缘指定颜色 纹理过滤：将纹理坐标浮点值映射到像素 GL_NEAREST ：取最近邻的像素颜色 GL_LINEAR ：根据相邻像素颜色插值 MipMap","link":"/2020/05/03/Internship-CG/"},{"title":"Internship-Diary-1","text":"实习日记Day1 5.14 上午一直在等邮件发pin密码什么的，但是一直也没有邮件。问了一下群友，群友说直接打电话给8000激活token就可以。8000小哥直接给我激活了之后发了我pin，然后一通激活各种设备软件。 Leader先拉我进了组微信群，群友一看00后的我都呆了哈哈哈然后配了一下远程桌面，连到公司的台式机工作。 pull了一下engine的代码，打算编译，结果因为公司内网给的IDE版本不是最新，耽误了我一下午的时间编译错误。。。晚上看了看render部分的文档就完事了 这个引擎实现还不算很完善，但是好像已经可以做到对接QQ程序，具体还要看看细节。渲染模块除了RHI抽象 还继续抽象了一层，什么renderPass那一块没有太看明白。 哦对了 今天上午UE5官方放出来了介绍视频，明年发布，群友后来热烈讨论了一番技术实现，听的我一头雾水，然后zxx大佬晚上就放出了一篇知乎大概介绍了一下大概的理解大概放几个名词后续查一下LOD软光栅化还有Tessellation一些细节","link":"/2020/05/15/Internship-Diary-1/"},{"title":"Internship-Diary-2","text":"实习日记Day2 5.15 上午开了个组会，先是跟QQ那边一起，做一个简单的周工作汇报然后是NE这边，新拉进来了一个网易大佬，我这远程入职还是很没有存在感 jiang同学做了一下Engine Editor的介绍讲了一下发展历史，功能区别，放了五个阶段，指出了一下进化的几个点，他提到说Editor大概可以类比于IDE，Script也可以算作Editor的一部分，然后展示了一下自己之前做的一个Demo，那个demo我看起来已经实现了大部分引擎的基本操作了。着实nb 下午跟mentor说我编译好了，接下去他说要我看一下文档自己操作一下Editor，然后看一下RHI里GL部分的实现。感觉这个GL实现应该和我的抽象结构差不多，只是RHI的抽象功能多得多，要好好看个几天吧。 后来就划了划水，看他们还在讨论UE5的事情。诶，原来我们组有一大半的人base杭州啊，有点意思。 感觉接下去一段时间都要去看这个RHI实现代码了，想在这几个月搞清楚这个引擎的架构，感觉蛮有意思~","link":"/2020/05/15/Internship-Diary-2/"},{"title":"C++面试知识点","text":"C++面试知识点 C++ const修饰指针const int* p不可改变指针值int* const p不可改变p指向修饰引用：const string&amp; str修饰成员函数void func() const {} 不可改变成员变量（const ClassName *this） static修饰全局变量&amp;函数：限定在当前编译单元修饰局部变量：开在静态区，只初始化一次，可用域为当前范围修饰成员函数：不可访问非静态成员，只能用类名调用，没有this修饰成员变量：只能类名调用，在静态区。在main函数执行之前分配内存。 inline复制函数代码调用函数不压栈，直接映射参数&amp;返回值类声明中函数都是inline建议编译器inline，有循环递归switch的不inline乱用会代码膨胀，且修改后重新编译所有调用虚函数可以内联但是失去运行时多态，只能className a;a.test(); this非静态函数中，指向调用它的对象，不可赋值（ClassName* const this）属于非静态成员函数默认第一个参数，可以std::bind volatile编译器会自动优化如int a = 2;b=a+2;cout&lt;&lt;b;不将a写入内存直接当作2调用。如果在b=a+2;前 a被其他线程或某种原因修改则出错声明后禁止编译器编译优化，强制写入读出内存。可以修饰指针 const sizeof数组sizeof为数组空间大小指针sizeof为指针本身大小（一半为4） 内存对齐结构体中存在内存对齐，假设pragma pack设定值为p当前类型大小为q为当前变量开空间时遵循开头位置offset被min(p,q)整除总开辟空间遵循可以被max({q},p)整除如int a;char b;char c;占用8char a;int b;char c;占用12#prama pack()可以设置为1,2,4,8等位域：限制某类型变量只占用若干二进制位，int a:2; a只占用两个bit extern可以在其他编译单元使用，可以代替部分include的工作。extern “C”{ … } 在c++中调用c风格代码 explicit修饰构造函数或转换函数（重载括号运算）可以防止隐式转换 如ClassName c = 1;会隐式调用构造函数ClassName(int)(参数只有一个或其余均有默认值)explicit声明后只能显示ClassName c = ClassName(1); friend可以访问private，且单向。 usingusing namespace / using namespace::nameC++11中派生类using base::base;可以重用父类构造函数相当于derived(params) : base(args){}还可以相当于typedef 给模板别名template&lt; typename T&gt;using Ref = std::share_ptr&lt; T&gt;; decltype检查实体声明类型并使用int a;decltype(a) 为int 可以直接声明变量可以后置声明返回值类型template&lt; typename IT&gt;auto fcn(IT a) -&gt; decltype(a){} 左右值引用右值引用：字符串常量，临时对象等等移动语义：move() 传入左/右值 返回右值引用原理：引用折叠：除了&amp;&amp;+&amp;&amp;=&amp;&amp;其他均为&amp;传入模板函数中的左值T自带一个&amp;精确传递：解决传入函数参数推测类型默认为左值问题 描述不太清楚 define一对一转换参数#define test(type) #type ：将type字面转为字符串##：连接两个字面值 多态编译期多态：函数&amp;运算符重载 ， 模板运行期多态：虚函数， 类型转换（dynamic_cast）RTTI 虚函数虚函数表：生成对象时产生，继承时继承父类虚函数表指针有虚函数的空类大小为4(vfptr) 无虚函数空类大小为1重写时覆盖虚函数表的函数指针构造函数不能虚函数：调用构造函数时没有虚表指针虚析构函数：被继承时一定虚析构，防止泄露纯虚函数：抽象类 虚继承/多继承防止菱形继承内存重复，采用虚表，继承时继承多个父类的虚表指针虚表存储虚基类内存偏移量 描述不清 内存分配new/delete:自动调用构造/析构函数，在堆区开内存，失败返回badalloc定位new new(p) int(2);在p指针位置开内存 其实就是返回int类型的pmalloc/free:不调用构造/析构，失败返回null，开内存位置不同于new *不清楚**对象内存限制：只能开在堆上：私有析构函数（在栈中开时会检测构造/析构函数）只能开在栈上：私有重载new&amp;delete 智能指针shared_ptr: 可以多个指向同一对象，有引用计数，计数归零析构对象delete 实现unique_ptr: 不可以多个指向同一对象，不可以赋值，可以右值赋值（move）赋值后销除原指针weak_ptr: 解决share_ptr死锁问题：两个资源相互引用，无法同时析构。相当于shared_ptr的容器，不增加引用计数，通过lock获得原share指针auto_ptr:可以赋值操作的unique 原标准中，C++11弃用 类型转换const_cast: 可以删除原对象const/volatile属性reinterpret_cast: 重新解释二进制数据，最强制转换，慎用static_cast: 基本同c中显式转换，可以父类-&gt;子类 （不安全）dynamic_cast: RTTI 运行时类型信息，可以父类转子类自动检测是否可以转换（仅支持有虚函数表的类） RTTI相关typeid 返回type_info 运行时对象类型type_info对象中保存的类型信息 lambda表达式[=]：接受所有值，按值[&amp;]：接受所有值，按引用[a]：接受a，按值[&amp;a]：接受a，按引用[&amp;,a]：接受a按值，接受其他所有按引用[=,&amp;a]：接受a按引用，接受其他所有按值[a] ( ) mutable {a++;} 按值接受a拷贝 修改a拷贝a值不变[ ] ( )-&gt;int{return 1;} 返回值类型int 链接库 静态链接：浪费内存空间，每个可执行程序对目标文件都要副本，一个模块更新需要重新编译。 动态链接：将对符号的重定位推迟到运行时，解决静态库的两个缺点。","link":"/2020/05/03/Internship-CPP/"},{"title":"Internship-Diary-5","text":"实习日记Day5 5.18 又是一个周一，早上起来差点错过组会。他们交流了一下这周需要做的事情，cue了我一下，我主要还是熟悉项目。mentor发微信说要我熟悉一下pipeline实现和Pipeline State Object (PSO)看了一下，大概的理解就是PSO是管线状态集，blending/rasterization/stencil&amp;depth的参数合集，然后GLES3Pipeline实现了一下把状态传递给gl，这里还是延迟传递，在draw之前才传参数 不知道是不是正确理解，然后又继续去看gl实现了，GL的实现看起来不算困难，主要就是抽象层数太多，比较细致，不是很容易读懂，而且我还没有搞清楚上层绘制的流程是怎么样的，感觉实现的这些类都有重叠的功能。 早晨起来开始工作也基本十点多十一点了，到下午3点左右吃顿饭，5点不到就出去划水了，晚上就更没心情工作了。。。还是要早睡早起，而且多点工作时间了，毕竟还要准备考试。。。挺过去就好了，好想去深圳啊，感觉他们挺欢乐得，还不用加班（猜的） 哦下午闲的没事翻moa里的项目组，发现IEG的引擎组还是挺多的~之前都没了解","link":"/2020/05/18/Internship-Diary-5/"},{"title":"Internship-Diary-5-7","text":"实习日记Day5 5.19 5.20 5.21 这三天太累了。。。日子过得都迷糊了 主要学了学Vulkan，把官方文档画三角形写了，前半部分还算比较清楚，有几个地方没有理解： Render Pass Present image view framebuffer这些的具体关系，这周末有空的时候整理一个博客出来吧。真就一千行代码画三角形，不愧是verbose 然后NE这边还是看Pipeline State Object切到GL试了一下弄了一个下午，结果因为没有显卡openGL驱动，我真吐了然后martain那边又更新了一下DX的PSO。具体的写在本地这边吧。 虽然学习时间并不短，但是这周还是侧重于VK了，NE这边进度很慢，周末得加时间补回来，争取下周开始进开发。VK这边架构有空的时候补一补，而且还得看Texture有关的东西，不管是GL还是DX，之前都忽略掉了。 还是多问点问题跟紧进度吧，不然这样存在感太低了，哪怕是问智障问题也要问！自己琢磨还是效率低下 接下去总结一下 Vulkan 结构流程 NE PSO抽象","link":"/2020/05/22/Internship-Diary-5-7/"},{"title":"Internship-Diary-May-25","text":"5.25就不按天记了，时间太少了不够用啊 过了一个完全划水的周六，周末补了两节数据库课。今天早上开个组会 Martain让我去写PSO重构那块，先是写点renderState，这块D3D已经写完了主要就是对照着原来的pipeline state去抄一下，然后原来有些没有实现的地方比如rasterizer那里查了一下GLES的支持，大概转换了一下state。有两个属性是GLES不支持的 FillMode 和 DepthBiasClamp还有MSAA那里我不知道GL怎么实现，明天查一下问一问 明天看一下我今天写的代码有没有问题，然后了解一下怎么去实现创建PSO和PSO的抽象，因为这部分D3D也还没有写。如果能搞明白就自己去实现一下，感觉大体的过程我知道，但是具体抽象出来哪些接口还不知道。 感觉这个就是要把OpenGL整体封装成DX/VK的创建模式，每个阶段都变成用Desc去Create对象，还是蛮通用的。 晚上补了一节半的数据库课，关系依赖东西这里有点太多，补的没有那么快。明晚上继续把这章听完，写点作业题。听不动数据库的时候还得看看组合数学。 考试时间大概出来了 组合数学 6月7日英语 6月8日下午数据库 6月9日下午14:30-16:30操作系统 6月15日下午 14:30-16:30（好像改成14号了？）计网 不知道 如果计网在15号之前，应该可以15号左右去深圳如果在之后18-20号可能要考虑提前去深圳？这时间有点烦人。","link":"/2020/05/25/Internship-Diary-May-25/"},{"title":"Internship-NextEngine-RHIopengl-1","text":"??? RHIPlatformHandle? ConstBuffer bind? Dynamic VBO? Render Pass? VBO &amp; Buffer RHI/Implement/GLES3 GLES3Buffer ConstBuffer VertexBuffer IndexBuffer GLES3ConstantBuffer 传给shader的uniform buffer 不太明白这个dynamic buffer的区别和实现 GLES3Context 还没看，应该就是设置渲染内容参数和swapbuffer GLES3Device 方法大集合 GLES3FrameBuffer 管理渲染缓存，默认是渲染到屏幕，绑定其他是离屏渲染 GLES3GpuPrograms 不知道 : TODO GLES3Pipeline 设置blend,rasterization,stencil&amp;depth参数，绘制前延迟应用设置 GLES3Program 创建，应用Program，AttachShader。 GLES3RenderPass 处理rendertarget，离屏渲染相关，实现没看懂 GLES3Sample 各种纹理采样参数设置 GLES3Shader 还没看 : TODO GLES3Texture 还没看 : TODO GLES3VBO VBO对象，绑定Vertex/Index Buffer 负责绘制等操作 dynamicVBO 不知道 : TODO GLES3Window 还没看 :TODO //总之还是各种类的OpenGL实现，实现并不难懂，但是上层抽象太多了，需要往上层看看。","link":"/2020/05/17/Internship-NextEngine-RHIopengl-1/"},{"title":"Learning-DB-lwt","text":"第一章 绪论一、数据库系统概论（一）基本概念 信息与数据的关系数据是信息的载体，信息是数据的内涵数据是信息的符号表示，而信息通过数据描述，又是数据语义的解释。 数据库①数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。（数据库的三个特点）②数据库的基本特征数据结构化 - 数据按一定的数据模型组织、描述和储存介质存储 - 通过磁盘等大量的、长期的存储数据共享 - 数据库可为各种用户共享，可以为不同的应用使用冗余性较小 - 数据库是一个有机的数据集成体，冗余度较小数据独立性 - 数据与程序间的互不依赖易扩展 - 能根据数据的增长和业务的变化扩充数据库数据由DBMS统一管理和控制用户数据库和系统数据库 数据管理系统（DMBS）DMBS的软件地位 数据库系统数据库系统是指在计算机系统中引入数据库后的系统。一般由数据库、数据库管理系统 （及其开发工具）、应用系统、数据库管理员（DBA）和用户构成。 （二）信息管理技术的发展 1、人工管理阶段 2、文件系统阶段 记录内有结构。 数据的结构是靠程序定义和解释的。 数据只能是定长的。 可以间接实现数据变长要求，但访问相应数据的应用程序复杂了。 文件间是独立的，因此数据整体无结构。 可以间接实现数据整体的有结构，但必须在应用程序中对描述数据间的联系。 数据的最小存取单位是记录。 3、数据库系统阶段 整体数据的结构化是数据库的主要特征之一 整体结构化 不再仅仅针对某一个应用，而是面向全组织 不仅数据内部结构化，整体是结构化的，数据之间具有联系 数据库中实现的是数据的真正结构化 数据的结构用数据模型描述，无需程序定义和解释 数据可以变长 数据的最小存取单位是数据项 二、数据模型与信息模型 （一）三个世界 （1） 现实世界：存在于人们头脑之外的客观世界,称为现实世界. （2） 信息世界：是现实世界在人们头脑中的反映.信息世界的基本概念： 实体：客观存在并能相互区别的事物。 属性：实体所具有的某一特征。 简单属性和复合属性 单值属性和多值属性 存储属性和派生属性 属性域：属性的取值范围。 键（码、key）：能唯一标识实体的最小属性集。–每一个实体集一定有实体键。 实体型：由实体名及其属性名集来表示。 实体值是实体型的具体内容 实体集：同类型实体的集合。 （3） 机器世界：信息世界的信息在机器世界中以数据形式存储.信息世界中数据描述的术语有：实体、实体集、属性、实体标识符 （二）信息模型的表示信息模型是现实世界到机器世界的一个中间层次。 实体集之间的联系（实体集之间的联系与实体集内部的联系）实体集之间的联系分为：一对一联系（1:1），一对多联系(1: n)，多对多联系(m: n) 信息模型的表示方法（实体-联系方法（E-R法））①E-R图的基本成分：实体集（矩形）、属性（椭圆形）、联系（菱形） （三）数据模型的组成 数据模型的三要素：数据结构、数据操作、数据的完整性①数据结构：数据类型、性质及数据之间的联系 →静态特性②数据操作：查询和更新（包括插入、删除、修改）两大基本操作 →动态特性③数据的完整性约束：一组数据完整性规则的集合 数据模型的分类①三种基本数据类型（层次模型、网状模型、关系模型）②面向对象数据模型③谓词模型（逻辑模型）④XML模型⑤非SQL数据模型⑥扩充的数据模型 （四）基本数据模型 层次模型： 网状模型网状模型与层次模型的根本区别：一个子结点可以有多个父节点；在两个结点时间可以有多种联系 关系模型（最重要）在关系模型中，把二维表称为关系，二维表由行和列组成。每行称为一个元组，每列称为一个属性。实体集之间的联系通过表格自然设置的，表之间还有型和值的隐式联系，均不需人为设置指针。姓名 科目语文 数学 英语甲不允许表中有表，例如 三种模型的比较特点模型 数据结构 联系表示的特点 优点 缺点 使用与效率 联系的方式层次模型 树结构 适合一对多，可间接表示多对多 数据结构简单，查询效率高；提供良好的完整性支持 不易表示多对多的联系；数据操作限制多，独立性较差 较难使用、效率较高 指针或路径网状模型 图结构 适合一对多，可间接表示多对多 较为直接地描述现实世界；存取效率较高 结构较复杂、不易使用；数据独立性较差 使用复杂、效率较高 指针或路径关系模型 表结构 便于表示多对多 有坚实的理论基础；结构简单、易用 查询效率较低 容易使用、效率较低 自然联系及创建联系 三、数据库系统 （一）三级模式结构（子模式、模式和内模式） 模式 （1）模式（概念模式或数据模式）是数据库中全体数据的逻辑结构和特征的描述。 （2）①一个数据库只有一个模式。 ②模式与具体应用程序无关，它只是装配数据的一个框架。 ③模式用语言描述和定义，需定义数据的逻辑结构、数据有关的安全性等。 子模式 （1）子模式（外模式或用户模式）用户所用的数据库结构 子模式是模式的子集 （2）①一个数据库可以有多个子模式；每个用户至少使用一个子模式。 ②同一个用户可以使用不同的子模式，而每个子模式可以分为多个不同的用户所用。 ③模式是对全体用户数据及其关系的综合与抽象，子模式是根据所需对模式的抽取。 内模式 （1）内模式（存储模式）是数据物理结构和存储方法的描述。 （2）①一个数据库只有一个内模式。内模式对用户透明。 ②一个数据库有多种文件组成。 ③内模式设计直接影响到数据库的性能。 数据独立性与二级映像功能 （1）数据独立性：数据与程序之间互不依赖性，一般分为物理独立性和逻辑独立性。 ①物理独立性是指数据库物理结构的改变不影响逻辑结构及应用程序。 ②逻辑独立性是指数据库逻辑结构的改变不影响应用程序。 （2）为实现数据独立性，数据库提供两级映像。 ①映像1。子模式/模式映像——&gt;模式生成子模式的规则 ②映像2。模式/内模式映像——&gt;模式在物理设备中的存储结构 （二）数据库系统体系结构 数据库系统、的外部的体系结构分为单用户式、主从式、客户/服务器式、分布式和并行结构等。 （三）数据库系统的组成 数据库由三大部分组成——硬件平台、软件系统及各类人员。 硬件设备（计算机设备、网络及其通信设施）； 软件系统（DBMS、操作系统、语言工具与开发环境、数据库应用软件、数据库等）； 人员（数据库管理员(DBA)、系统分析员及设计人员、用户等）。 数据库系统的特点 (1)数据集成性好。①统一的数据模型。 ②面向多个应用。 ③局部与全局的独立统一。 (2)数据共享性高。①充分共享且范围广。 ②冗余度低。 ③易扩充。 (3)数据独立性强。一个具有数据独立性的系统可称为面向数据的系统,即数据的逻辑结构、存储结构与存取方式的改变不影响应用程序,而应用的改变也不至于马上引起数据库结构的调整。 (4)数据控制力度大。数据库中数据由DBMS统一管理和控制。由于数据库是共享的，即多个用户可以同时存取数据库中的数据,甚至可以共享数据库中同一个数据。 总结：- 数据库系统概述 - 数据库的基本概念 - 数据管理的发展过程 - 信息模型与数据模型 - 信息模型，（E-R 模型） - 数据模型的三要素（数据结构、数据操作、数据的完整性约束） - 三种基本数据模型（层次模型、网状模型、关系模型） - 数据库系统的3级结构和两级映像保证了较高的数据独立性。 - 数据库系统的结构 - 数据库系统三级模式结构 - 数据库系统两层映像系统结构 - 数据库系统的组成 数据库系统是包括DBMS.数据库在内的整个计算机系统。主要由硬件平台、软件系 统及各类人员组成。数据库系统的特点是能对数据实行统一、高效的集中管理,提高数 据独立性,实现高度共享,保证数据的完整性与安全性。 DBMS是数据库系统的核心,它是负责数据库的定义、建立.操纵、管理和维护的系 统软件,其职能是有效地实现数据库3级模式之间的转换。第二章 关系数据库一、关系模型（一）关系1、域：域是一组具有相同数据类型的值的集合2、笛卡儿积：所有域的所有取值的集合给定一组域D1，D2，…，Dn ，D1，D2，…，Dn的笛卡尔积为： D1×D2×…×Dn ＝｛（d1，d2，…，dn）｜diDi，i＝1，2，…，n允许一组域中存在相同的域3、元组：笛卡尔积（d1，d2，…，dn）中每一个元素(张清玫，计算机专业，李勇)、(张清玫，计算机专业，刘晨)等都是元组4、分量：笛卡尔积元素（d1，d2，…，dn）中的每一个值di张清玫、计算机专业、李勇、刘晨等都是分量5、基数：若Di（i＝1，2，…，n）为有限集，其基数为mi（i＝1，2，…，n），则D1×D2×…×Dn的基数M为： 6、关系：D1×D2×…×Dn的子集叫作在域D1，D2，…，Dn上的关系，表示为 R（D1，D2，…，Dn） ——关系即为笛卡儿积的一个子集R：关系名， n：关系的元、目或度当n=1时，该关系为单元关系或一元关系，当n=2时，该关系为二元关系。 7、元组（t）：关系中的每个元素是关系中的元组(关系是元组的集合)。8、属性：①关系中不同列可以对应相同的域，所以给每一列起一个名字称为属性。②n目关系必须有n个属性。③属性包括属性的型和属性的值。④属性在关系中某个具体值，称为分量。 9、键①候选键（候选码、码）若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选键。②全键（全码）关系模式的所有属性组是这个关系模式的候选键，称为全键。③主键（主码、主关键字）若一个关系有多个候选键，则选定其中一个为主键。④外键设F是基本关系R的一个或一组属性，但不是关系R的键。如果F与基本关系S的主键Ks相对应，则称F是基本关系R的外键基本关系R：参照关系 基本关系S：被参照关系或目标关系 10、三类关系①基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示。②查询表：查询结果对应的表③视图表：由基本表或其他视图表导出的表，是虚表(不对应实际存储的数据)。 （二）关系模式1、什么是关系模式？①关系模式是关系结构的描述和定义，即二维表的表结构定义。——关系模式是型②关系实质上是一张二维表，每一行是一个元组，每一列是一个域 ——关系是值关系模式是对关系的描述 元组集合的结构（属性构成、属性来自的域、属性与域之间的映象关系） 元组语义以及完整性约束条件 属性间的数据依赖关系集合2、定义关系模式关系模式可以形式化地表示为 R（U，D，DOM，F）通常简记为R(U)或R(A1,…An) R 关系名 U 组成该关系的属性名集合 D 属性组U中属性所来自的域 DOM 属性向域的映象集合 F 属性间的数据依赖关系集合3、关系模式与关系 静态的、稳定的；对关系的描述关系模式 关系 关系模式在某一时刻的状态；动态的、随时间不断变化的 第三章 关系数据库标准语言SQL一、SQL概述SQL结构化查询语言，是关系数据库的标准语言（一）SQL的产生与发展（二）SQL的特点1、综合统一：集数据定义语言、数据操纵语言、数据控制语言的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动。2、高度非过程化：只要提出“做什么”，无需了解存取路径。3、以同一种语法结构提供多种使用方式：SQL是独立的语言，又是嵌入式语言。4、语言简洁，易学易用5、面向集合的操作方式：操作对象、查找结果是元组的集合 （三）SQL的基本概念 SQL数据库层次结构为三级结构，支持关系数据库的3级结构。在SQL中，关系模式(模式)称为“基本表”(base table); 存储模式(内模式)称为‘存储文件”子模式(外模式)称为“视图”;元组称为“行”;属性称为“列”。 二、 学生—课程数据库 学生表：Student(Sno,Sname,Ssex,Sage,Sdept) 课程表：Course(Cno,Cname,Cpno,Ccredit) 学生选课表：SC(Sno,Cno,Grade)Student表学 号Sno 姓 名Sname 性 别 Ssex 年 龄 Sage 所 在 系 Sdept200215121200215122200215123200515125 李勇刘晨王敏张立 男女女男 20191819 CSCSMAISCourse表课程号Cno 课程名Cname 先行课Cpno 学分Ccredit1234567 数据库数学信息系统操作系统数据结构数据处理PASCAL语言 51676 4243424SC表学 号Sno 课程号 Cno 成绩 Grade 200215121 200215121 200215121 200215122 200215122 1 2 3 2 3 92 85 88 90 80 三、数据定义 （一）模式的定义与删除1、模式定义语句：CREATE SCHEMA&lt;模式名&gt;AUTHORIZATION&lt;用户名&gt;; [例1]定义一个学生-课程模式S-T CREATE SCHEMA “S-T” AUTHORIZATION WANG; 为用户WANG定义了一个模式S-T如果没有指定&lt;用户名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt; 2、模式删除语句：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;CASCADE(级联) 删除模式的同时把该模式中所有的数据库对象全部删除RESTRICT(限制) 如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。 当该模式中没有任何下属的对象时 才能执行。[例2] DROP SCHEMA ZHANG CASCADE； 删除模式ZHANG 同时该模式中定义的表TAB1也被删除 （二）基本表的定义、删除与修改1、定义基本表：CREATE TABLE &lt;表名&gt;（&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ][，&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] …[，&lt;表级完整性约束条件&gt; ] ）；如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。[例3] 建立“学生”表Student，学号是主码，姓名取值唯一。 CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY， /* 列级完整性约束条件/ Sname CHAR(20) UNIQUE， / Sname取唯一值*/ Ssex CHAR(2) default ‘男’, Sage SMALLINT not null， Sdept CHAR(20) check (Sdept in (‘CS’,’EE’,’EN’)), place varchar(20) )； ——数据类型数据类型 含义CHAR(n) 长度为n的定长字符串VARCHAR(n) 最大长度为n的变长字符串INT 长整数（也可以写作INTEGER）SMALLINT 短整数NUMERIC(p，d) 定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字REAL 取决于机器精度的浮点数Double Precision 取决于机器精度的双精度浮点数FLOAT(n) 浮点数，精度至少为n位数字DATE 日期，包含年、月、日，格式为YYYY-MM-DDTIME 时间，包含一日的时、分、秒，格式为HH:MM:SS 2、修改基本表：ALTER TABLE &lt;表名&gt;[ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ][ DROP &lt;列名&gt; ][ Modify &lt;列名&gt; &lt;数据类型&gt; ][ADD constraint 主键名称 primary key (主键字段1,主键字段2)]；[例4]向Student表增加“入学时间”列，其数据类型为日期型。 ALTER TABLE Student ADD S_entrance DATE；不论基本表中原来是否已有数据，新增加的列一律为空值。[例5]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。 ALTER TABLE Student Modify Sage INT； 3、删除基本表： DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］； RESTRICT：删除表是有限制的。 欲删除的基本表不能被其他表的约束所引用 如果存在依赖该表的对象，则此表不能被删除 CASCADE：删除该表没有限制。 在删除基本表的同时，相关的依赖对象一起删除若表上建有视图，选择RESTRICT时表不能删除，如果选择CASCADE时可以删除表，视图也自动被删除 （三）索引的建立与删除1、建立索引的目的：加快查迅速度2、建立索引：CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…)；[例6] CREATE CLUSTER INDEX Stusname ON Student(Sname)； 在Student表的Sname（姓名）列上建立一个聚簇索引在最经常查询的列上建立聚簇索引以提高查询效率一个基本表上最多只能建立一个聚簇索引经常更新的列不宜建立聚簇索引 3、删除索引：DROP INDEX &lt;索引名&gt;； 四、数据查询数据查询：SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] …[ WHERE &lt;条件表达式&gt; ][ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ][ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]； （一）单表查询1、选择表中若干列（1）查询指定列[例1] 查询全体学生的学号与姓名。 SELECT Sno，Sname FROM Student；（2）查询所有列 在SELECT关键字后面列出所有列名 将&lt;目标列表达式&gt;指定为 *[例3] 查询全体学生的详细记录。SELECT Sno，Sname，Ssex，Sage，SdeptFROM Student； 或SELECT *FROM Student；SELECT子句的&lt;目标表达式&gt;可以为：算术表达式（2004-Sage）、字符串常量（‘Year of Birth’）、函数、列别名（Sname NAME） 2、选择表中的若干元组（1）消除取值重复的行（如果没有指定DISTINCT关键词，则缺省为ALL） 指定DISTINCT关键词，去掉表中重复的行 SELECT DISTINCT Sno FROM SC；查 询 条 件 谓 词比 较 =，&gt;，&lt;，&gt;=，&lt;=，!=，&lt;&gt;，!&gt;，!&lt;；NOT+上述比较运算符确定范围 BETWEEN AND，NOT BETWEEN AND确定集合 IN，NOT IN字符匹配 LIKE，NOT LIKE（ESCAPE ‘＼’ 表示“ ＼” 为换码字符）空 值 IS NULL，IS NOT NULL（IS不能用=代替）多重条件（逻辑运算） AND，OR，NOT（AND的优先级高于OR） 3、ORDER BY子句 可以按一个或多个属性列排序 升序：ASC；排序列为空值的元组最后显示 降序：DESC（缺省值为升序）；排序列为空值的元组最先显示[例4] 查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。 SELECT Sno，Grade FROM SC WHERE Cno= ‘ 3 ‘ ORDER BY Grade DESC； 4、聚集函数 计数 COUNT（[DISTINCT|ALL] *）/COUNT（[DISTINCT|ALL] &lt;列名&gt;） 计算总和 SUM（[DISTINCT|ALL] &lt;列名&gt;） 计算平均值 AVG（[DISTINCT|ALL] &lt;列名&gt;） 最大最小值 MAX（[DISTINCT|ALL] &lt;列名&gt;）/MIN（[DISTINCT|ALL] &lt;列名&gt;） 5、GROUP BY子句=&gt;细化聚集函数的作用对象，——按指定的一列或多列值分组，值相等的为一组 计算最小函数依赖集输入:一个函数依赖集F输出:F的一个等价的最小函数依赖集Fm。步骤:(1)用分解规则,使F中每个函数依赖的右部仅含单属性。此步为等价分解。(2)去掉各依赖左部多余的属性。一个一个地检查左部非单个属性的函数依赖。例如,XY→A,要判断Y是否多余,在分解后的F中求X+ ,若A∈X+，则Y是多余的可以去掉。此步为等价消属性。(3)去掉多余的函数依赖。逐一检查上步结果F中的各函数依赖X→A,并将X→A从F中去掉,然后在剩余的F中求X+ ,若A∈X+ ,则X→A多余(由定理4.6),去掉X→A,否则不能去掉。依次做下去，直到找不到冗余的函数依赖。此步为等价消依赖(也可用Armstrong公理消去F中多余的函数依赖)。 分解为BCNF方法需要消除不包含关系。 [2] 假设R(U)不是BCNF, X是R的属性子集，A是R的单个属性，X-&gt;A是导致违反BCNF的函数依赖，则将R分解为R-A以及XA。 若R-A以及XA仍然不是BCNF，则在R-A以及XA递归地执行上述分解。例一：SCT：(S#，CNAME，TNAME)，FD:TNAME→CNAME。可分解为SC(S#，TNAME)和CT(CNAME，TNAME)，它们都是BCNF。 无损连接性检验输入:关系模式R(A1,A2.,..,An),函数依赖集F,分解p={R1,R2.,.,Rn}.输出:确定ρ是否具有无损连接性。方法:(1)构造一个k行n列的表,第i行对应于关系模式Ri,第j列对应于属性Aj。如果A,∈R,则在第i行第j列上放符号a;,否则放符号bij.(2)重复考察F中的每一个函数依赖,并修改表中的元素。其方法如下:取F中一个函数依赖X→Y,在X的分量中寻找相同的行,然后将这些行中Y的分量改为相同的符号，如果其中有aj,则将bij改为aj;若其中无aj, ,则全部改为bij (i是这些行的行号最小值)。(3)若发现表中某一行变成了a1,a2,.,an,则分解p具有无损连接性;若F中所有函依赖都不能再改变表中的内容,且没有发现这样的行,则分解ρ不具有无损连接性。方法2： 转换成3NF且保持函数依赖的分解例1：关系模式R&lt;U,F&gt;，其中U={C,T,H,R,S,G}，F={CS→G,C→T,TH→R,HR→C,HS→R}，将其分解成3NF并保持函数依赖。(一)计算F的最小函数依赖集① 利用分解规则，将所有的函数依赖变成右边都是单个属性的函数依赖。由于F的所有函数依赖的右边都是单个属性，故不用分解举个例子就是：CS→GB 变成 CS→G CS→B② 去掉F中多余的函数依赖设CS→G为冗余的函数依赖，则去掉CS→G，得：F1={C→T,TH→R,HR→C,HS→R}计算(CS)F1+： G不属于(CS)F1+ 故这个不是冗余的函数依赖同理：分别判断,C→T,TH→R,HR→C,HS→R 是不是冗余的函数依赖③ 去掉F5中各函数依赖左边多余的属性（只检查左部不是单个属性的函数依赖）,没有发现左边有多余属性的函数依赖。举例：CS→G 去掉C得到S→G这是无法由后面的依赖推出的，同理去掉S，同样的方法对其他所有的函数依赖进行检验(二)由于R中的所有属性均在F中都出现，所以转下一步。举例： U={C,T,H,R,S,G}，F={CS→G}由于T,H,R没有在F中出现，于是将R1={THP}作为一个分解关系故最小函数依赖集为：F={CS→G,C→T,TH→R,HR→C,HS→R}(三)对F按具有相同左部的原则分为：R1=CSG，R2=CT，R3=THR，R4=HRC，R5=HSR。所以ρ={R1(CSG),R2(CT),R3(THR),R4(HRC),R5(HSR)}。相同左部分的原则：举例：C→T ,C→A是相同的左部，则将二者合并为一个关系C→AT 二、需求分析（一）重点1、信息要求2、处理要求3、功能要求4、企业环境特征（二）方法1、调查用户需求的步骤 （1）了解组织的机构设置 （2）主要业务活动和职能 （3）了解系统的各种外部要求 （4）确定系统边界2、常用的调查方法（1）检查文档 （2）跟班作业 （3）面谈调研 （4）网上搜集（问卷调查）（三）工具1、数据流图（DED）→表达了数据与处理的关系 2、数据字典（DD）→对数据库中数据的描述信息的集合（1）作用 ：①满足DBMS快速查询有关对象的要求。②供数据库管理员掌握整个系统运行的情况。（2）内容：①数据库系统所有对象及其属性的描述信息。②数据库系统对象之间关系的描述信息。③数据安全性、完整性约束条件、数据库日志等。④记录数据字典变化的历史。（3）数据库应用系统的DD数据项、数据结构、数据流、数据存储、处理过程①数据项描述＝｛数据项名，数据项含义说明，别名，数据类型，长度， 取值范围，取值含义，与其他数据项的逻辑关系｝例：数据项名：订货单号 类型： CHAR 长度： 8 别名： 采购单号 取值范围：10000000–99999999②数据结构是若干数据项有意义的集合。描述＝｛数据结构名，含义说明，组成:｛数据项或数据结构｝｝例：数据结构：采购细节 说明：作为采购计划的组成部分，说明对某个产品要采购哪些零件，哪种零件采购多少数量。 组成：零件号、零件名、数量③数据流表示加工处理过程的输入或输出数据。 描述＝｛数据流名，说明，数据流来源，数据流去向，组成:｛数据结构｝，平均流量，高峰期流量｝例：数据流名：采购计划 说明：由各产品所需零件数，选定的供应商，审核情况组成采购零配件计划。 来源：确定采购计划 去向：编制订货单 数据结构：–采购细节 –采购审核④ 数据存储是处理过程中要存取的数据。描述＝｛数据存储名，说明，编号，流入的数据流，流出的数据流，组成:｛数据结构｝，数据量，存取方式｝例：数据存储名：产品 说明：对每种产品的品名、规格的描述，并对每种产品做成本预算。在核对生产计划书的成本时用。 输出数据流：预算 组成：产品号、产品名、预算 数据量：每月30—40件 存取方式：随机存取⑤处理过程是对加工处理过程的描述。描述＝｛处理过程名，说明，输入:｛数据流｝，输出:｛数据流｝，处理:｛简要说明｝｝例：处理过程：确定采购计划 说明：对要采购的每一零件，根据零件库存量确定采购数量， 再根据每位供应商的报价选择适当的供应商，制定采购 计划。 输入：供应商报价、零件库存、已批准生产计划 输出：采购计划 简要说明:（1）对应采购的每种零件查找供应商报价表，选择报价最低的供应商号。 （2）将此供应商号填入应采购零件表的相应列中。 三、概念结构设计（一）方法1、基本方法（1）自顶向下（2）自底向上 自底向上概念结构设计方法通常分为两步：①抽象数据并设计局部视图②集成局部视图（3）逐步扩张（4）混合策略 （二）E-R图1、数据抽象（1）聚集：定义了某一类型的组成成分。它抽象了对象内部类型和成分之间的“is part of”的语义。（2）概括（继承）：定义类型之间的一种子集联系。它抽象了类型之间的“is subset of”的语义。（3）数据抽象层次：当反复利用概括和聚集进行数据抽象时，就可以形成对象的层次关系2、属性单值属性：只能有一个值的属性，用椭圆表示。多值属性：可能有多个值的属性，用双椭圆表示。派生属性：数据库中不存在，通过某种算法推导出来的属性，用虚椭圆表示。复合属性：包含其它属性的属性。 3、基数 在相互联系的实体中，实体出现一次而可能引起的另一个实体出现的最小和最大次数称为前一个实体的基数。 4、弱实体必须以另一个实体或多个实体的存在为前提的实体。用双线矩形框表示。 （三）局部视图设计1、确定局部结构范图2、逐一设计分E-R图①作为“属性”，一般不具有需要描述的性质。②属性不能与其他实体具有联系。 （四）合并E-R图合并的过程实际上是一个发现冲突和解决冲突的过程。1、合并方法①二元合并法：两个局部E-R图的合并，并产生一个E-R图。②多元合并法：同时将多个局部E-R图一次合并。2、冲突处理 （1）属性冲突 属性值类型、取值范围等发生冲突：尽量大的覆盖。 （2）命名冲突 同名异义、异名同义：重新命名。 （3）结构冲突 ①同一对象在不同视图中有不同抽象：统一为实体或属性。 ②同一实体在不同视图中属性组成不同：取并。 ③相同实体间联系在不同视图中呈现不同类型：应用语义。3、消除数据冗余冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。 （1） 用分析法消除冗余数据 例：实发工资、应发工资 注意：并不是所有的冗余都必须消除。有时为了提高效率，不得不以冗余为代价。 （2）利用关系规范化理论来消除冗余联系 ① 确定局部E-R图实体之间的函数依赖。 ② 求F的最小依赖集Fm，求其差集，即 D=F-Fm ③ 逐一考察D中每一函数依赖，确定是否为冗余，若是，就把它去掉。 （3）视图集成的原则①整体概念结构内部必须具有一致性，即不能存在互相矛盾的表达。②整体概念结构能准确地反映每个局部结构,包括属性、实体及实体间的联系。③整体概念结构能满足需要分析阶段所确定的所有要求。 四、逻辑结构设计（一）逻辑结构设计的步骤1、将基本E-R图转换为关系模型（一组关系模式）2、对关系模式进行优化3、设计合适的用户子模式 （二）E-R图向关系模式的转换1、实体与实体属性的转换一个实体型转换为一个关系模式。实体的属性就是关系的属性。实体的主键就是关系的主键。2、实体间联系的转换（1）一个1：1联系可以转换为一个独立的关系模式，也可以与任意一端对应关系模式合并。（2）一个1：n联系可以转换为一个独立的关系模式，也可以与n端对应关系模式合并。（3）一个m：n联系可以转换为一个独立的关系模式，与该联系相连的各实体的主键以及联系本身的属性均转换为关系模式的属性，而关系模式的主键为各实体主键的组合。（4）3个或3个以上实体间的一个多元联系转换为一个关系模式，与该多元联系相连的各实体的主键以及联系本身的属性均转换为关系模式的属性，而关系模式的主键为各实体主键的组合。（5）同一实体集的实体间的联系（自联系），也可按上述1：1，1：n，和m: n的3种情况分别处理。（三）关系模式的优化模式优化的方法通常如下: (1)确定数据依赖。根据需求分析阶段所得到的语义,确定各关系模式属性之间的数据依赖,以及不同关系模式属性间的数据依赖。 (2)对各关系模式之间的数据依赖进行最小化处理,消除冗余的联系。 (3)确定各关系模式的范式,并根据需求分析阶段的处理要求,确定是否要对它们进行合并或分解(并非规范化程度越高越好,需权衡各方面的利弊)。 (4)对关系模式进行必要的调整,以提高数据操作的效率和存储空间的利用率。通常可采用垂直分割和水平分割的方法。 （四）用户子模式的设计1、使用符合用户习惯的别名2、对不同用户定义不同的子模式3、简化用户对系统的使用 五、数据库物理设计数据库的物理设计通常分两步： （1）确定数据库的物理结构 （2）评价物理结构（时间和空间效率） （一）物理设计的内容和要求通常对关系数据库物理设计的主要内容：（1）为关系模式选取存取方法。（2）设计关系、索引等数据库文件的物理存储结构 （二）存取方法与存储结构1、关系模式存取方法（1）索引存取方法①在经常用于连接操作的列上建立索引②在经常按某列的顺序访问记录的列上建立索引③为经常有查询、ORDER BY 、GROUP BY、UNION和DISTINCT的列建立索引。④在内置函数的列上建立索引。如设有表:职员(职员号、姓名、工资、部门) ,要知道每个部门职员的平均工资,可用以.下的语句查询:SELECT部门,AVG(工资) FROM 职员GROUP BY部门 （2）聚簇存取方法①通过聚簇键进行访问或连接是该关系的主要应用，与聚簇键无关的其他访问很少。尤其当SQL语句中包含与聚簇键有关的ORDER BY、GROUP BY . UNION、DISTINCT等子句或短语时,使用聚簇特别有利,可以省去对结果集的排序操作。②对应每个聚簇键值的平均元组数较多。太少了,聚簇效益不明显,甚至浪费块的空间。③聚簇键值相对稳定，以减少修改聚簇键值所引起的维护开销。 （3）哈希存取方法①模糊查询。当记录是基于Hash列值进行模糊查询时,如查询职工号以字符“M2”开始的所有职工。②范围查询。当记录是基于Hash列值的范围进行查询没时，如查询职工号在“M200000”到“M200100”之间的所有职工。③非Hash列查询。即基于一个其他列而不是基于Hash列进行查询。例如,如果职工表基于职工号进行Hash映射,那么不能用Hash法查询姓名列的记录。④Hash列部分查询。即基于Hash列的一部分进行查询时。例如,选课表基于学号和课程号进行Hash映射,那么就不能只基于学号列来查询记录。⑤常更新Hash列。当Hash列被更新时,DBMS必须删除整条记录,并且有可能将它重新定位于新地址。因此,经常更新Hash列会影响系统性能。 2、确定数据库的存储结构（1）确定数据的存放位置（2）确定系统配置 （三）性能评价1、存取效率：每个逻辑存取所需的平均物理存取次数的倒数2、存储效率：每个要加工的数据所需实际辅存空间的平均字节数的倒数来度量。3、其他性能 六、数据库实施与维护（一）数据库实施1、定义数据结构 筛选数据2、组织数据入库 转换数据格式 输入数据 校验数据3、编制与调试应用程序4、数据库试运行 （二）数据库的维护1、数据的转储与恢复。2、数据库的安全性、完整性控制。3、数据库的性能监督、分析和改造。4、数据库的重组织与重构造。 第六章 数据库保护与事务管理一、数据库的安全性（一）计算机安全性概述1、三类计算机系统安全性问题技术安全类、管理安全类、政策法律类 2、安全标准①TCSEC标准（安全策略、责任、保证、文档）②CC标准（安全功能保证、安全保证要求） （二）数据库安全性控制1、身份认证用户标识与鉴别（用户标识、口令、用户名和口令易被窃取）2、访问控制（自主访问控制DAC-&gt;C2级、强制访问控制MAC-&gt;B1）3、自主访问控制方法（数据对象、操作类型）定义访问权限称为授权4、授权与回收（1）GRANT GRANT语句的一般格式： [例1] 把查询Student表权限授给用户U1 GRANT SELECT ON TABLE Student TO U1;[例2] 把对Student表和Course表的全部权限授予用户U2和U3 GRANT ALL PRIVILIGES ON TABLE Student, Course TO U2, U3;[例3] 把对表SC的查询权限授予所有用户 GRANT SELECT ON TABLE SC TO PUBLIC;[例4] 把查询Student表和修改学生学号的权限授给用户U4　 GRANT UPDATE(Sno), SELECT ON TABLE Student TO U4; 对属性列的授权时必须明确指出相应属性列名 （2）REVOKE REVOKE语句的一般格式为：[例8] 把用户U4修改学生学号的权限收回 REVOKE UPDATE(Sno) ON TABLE Student FROM U4;[例9] 收回所有用户对表SC的查询权限 REVOKE SELECT ON TABLE SC FROM PUBLIC;[例10] 把用户U5对SC表的INSERT权限收回 REVOKE INSERT ON TABLE SC FROM U5 CASCADE ; 将用户U5的INSERT权限收回的时候必须级联（CASCADE）收回 系统只收回直接或间接从U5处获得的权限 （3）创建数据库模式的权限DBA在创建用户时实现 CREATE USER语句格式 5、数据库角色 数据库角色：被命名的一组与数据库操作相关的权限①角色的创建CREATE ROLE &lt;角色名&gt;②给角色授权GRANT &lt;权限&gt;［，&lt;权限&gt;］… ON &lt;对象类型&gt;对象名 TO &lt;角色&gt;［，&lt;角色&gt;］…③将一个角色授权给其他角色或用户GRANT &lt;角色1&gt;［，&lt;角色2&gt;］…TO &lt;角色3&gt;［，&lt;用户1&gt;］…［WITH ADMIN OPTION］④角色权限的收回REVOKE &lt;权限&gt;［，&lt;权限&gt;］…ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;［，&lt;角色&gt;］… 6、强制访问控制方法主体：系统中的活动实体客体：系统中的被动实体、受主体操控  强制存取控制规则 (1)仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 (2)仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体  实现MAC时要首先实现DAC 原因：较高安全性级别提供的安全保护要包含较低级别的所有保护 （三）视图机制 把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护 主要功能是提供数据独立性，无法完全满足要求 间接实现了支持存取谓词的用户权限定义 （四）审计（Audit）1、什么是审计 审计日志（Audit Log）：将用户对数据库的所有操作记录在上面 DBA利用审计日志找出非法存取数据的人、时间和内容 C2以上安全级别的DBMS必须具有2、审计=&gt;用户级审计、系统级审计AUDIT语句：设置审计功能NOAUDIT语句：取消审计功能［例15］对修改SC表结构或修改SC表数据的操作进行审计 AUDIT ALTER，UPDATE ON SC；［例16］取消对SC表的一切审计 NOAUDIT ALTER，UPDATE ON SC； （五）数据加密1、数据加密：防止数据库数据在存储和传输中失密的有效手段2、加密的基本思想3、加密方法：替换、置换、混合 （六）统计数据库安全性规则1：任何查询至少要涉及N(N足够大)个以上的记录规则2：任意两个查询的相交数据项不能超过M个规则3：任一用户的查询次数不能超过1+(N-2)/M 二、数据库完整性数据库的完整性=&gt;数据库的正确性和相容性 数据的正确性 是指数据是符合现实世界语义，反映了当前实际状况的； 数据的相容性 是指数据库同一对象在不同关系表中的数据是符合逻辑的；1、提供定义完整性的约束条件的机制2、提供完整性检查的方法3、违约处理 （一）实体完整性1、定义 关系模型的实体完整性 CREATE TABLE中用PRIMARY KEY定义 单属性构成的码有两种说明方法 （列级约束条件、表级约束条件） 对多个属性构成的码只有一种说明方法（定义为表级约束条件）［例1］将Student表中的Sno属性定义为码 (1)在列级定义主码 CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY， /在列级定义主码/ Sname CHAR(20) NOT NULL， Ssex CHAR(2) ， Sage SMALLINT， Sdept CHAR(20) );(2)在表级定义主码 CREATE TABLE Student (Sno CHAR(9)， Sname CHAR(20) NOT NULL， Ssex CHAR(2) ， Sage SMALLINT， Sdept CHAR(20)， PRIMARY KEY (Sno ) ); /在表级定义主码/ 2、实体完整性检查和违约处理（1）检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查记录中主码值是否唯一的一种方法是进行全表扫描（2）检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改 （二）参照完整性1、定义 在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码 用REFERENCES短语指明这些外码参照哪些表的主码［例3］ 定义SC中的参照完整性 CREATE TABLE SC (Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT， PRIMARY KEY (Sno， Cno)， /在表级定义实体完整性/ FOREIGN KEY (Sno) REFERENCES Student(Sno)， /在表级定义参照完整性/ FOREIGN KEY (Cno) REFERENCES Course(Cno) /在表级定义参照完整性/2、参照完整性检查和违约处理 一个参照完整性将两个表中的相应元组联系起来 对被参照表和参照表进行增删改操作时有可能破坏参照完整性，必须进行检查① 在被参照关系(主表)中删除元组的问题 违约情况：从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。 违约反应策略：a) 级联删除(Cascades) 将参照关系(子表)中所有外码值与被参照关系(主表)中要删除元组主码值相同的元组一起删除b) 受限删除/拒绝(Restricted) 仅当参照关系(子表)中没有任何元组的外码值与被参照关系(主表)中要删除元组的主码值相同时, 系统才执行删除操作, 否则拒绝此操作c) 置空值删除(NULLIFIES) 删除被参照关系(主表)的元组, 并将参照关系(子表)中相应元组的外码置空值。 ② 在参照关系(子表)中插入元组的问题 违约情况：SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 违约反应策略：a) 受限插入 仅当被参照关系(主表)中存在相应的元组，其主码值与参照关系(子表)中要插入元组的外码值相同时，系统才执行插入操作，否则拒绝此操作b) 递归插入 首先向被参照关系(主表)插入相应的元组，其主码值等于参照关系(子表)插入元组的外码值，然后向参照关系(子表)插入元组 ③ 在被参照关系(主表)中修改主码 违约情况：修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 违约反应策略：a) 级联修改：修改被参照关系中主码值的同时，用相同的方法修改参照关系中相应的外码值b) 受限修改/拒绝：拒绝此修改操作。只当参照关系中没有任何元组的外码值等于被参照关系中某个元组的主码值时，这个元组的主码值才能被修改c) 置空值修改：修改被参照关系中主码值，同时将参照关系中相应的外码值置为空值 ④ 在参照关系(子表)中修改外码(同时是主码属性) 违约情况：SC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 违约反应策略：a) 受限修改 仅当被参照关系(主表)中存在相应的元组，其主码值与参照关系(子表)中要修改元组的外码值相同时，系统才执行修改操作，否则拒绝此操作。b) 递归修改 首先修改被参照关系(主表)相应的元组，其主码值等于参照关系(子表)要修改元组的外码值，然后修改参照关系(子表)插入元组。 总结： 违约反应策略：a) 不允许修改主码。b) 允许修改主码，但必须保证主码值的唯一性和非空性，否则拒绝修改。  允许修改关系主码的策略：(1) 修改的是被参照关系的主码时，还必须检查参照关系，是否存在这样的元组，其外码值等于被参照关系的主码值。(2) 当修改的是参照关系的外码(同时是主码属性)时，还必须检查被参照关系，是否存在这样的元组，其主码值等于参照关系的外码值。 参照完整性违约处理 拒绝(NO ACTION)执行不允许该操作执行。一般设置为默认策略。 级连(CASCADE)操作当删除或修改被参照表(Student)的一个元组造成了与参照表(SC)的不一致，则删除或修改参照表中的所有造成不一致的元组例如，删除Student表中的元组，Sno值为200215121，则从要SC表中级连删除 SC.Sno=’200215121’的所有元组 设置为空值（SET-NULL）当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。 限定（RESTRICT）操作 修改为默认值(SET DEFAULT) （三）用户定义的完整性1、属性上的约束条件的定义 列值非空（NOT NULL短语） 列值唯一（UNIQUE短语） 检查列值是否满足某个条件（CHECK短语）2、属性上的约束条件检查和违约处理 当往表中插入元组或修改属性的值时，RDBMS就检查属性上的约束条件是否被满足。 如果不满足则操作被拒绝执行。3、元组上的约束条件的定义 在CREAT TABLE语句中可以用CHECK短语定义，即元组级的限制。 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件4、元组上的约束条件检查和违约处理 当往表中插入元组或修改属性的值时，RDBMS就检查元组上的约束条件是否被满足。 如果不满足则操作被拒绝执行。 （四）完整性约束命名字句 在CREATE TABLE语句中提供了完整性约束命名子句CONSTRAINT，用来对完整性约束条件命名。 完整性约束命名子句CONSTRAINT &lt;完整性约束条件名&gt;［NOT NULL|UNIQUE|PRIMARY KEY短语|FOREIGN KEY短语|CHECK短语］ 修改表中的完整性限制使用ALTER TABLE语句修改表中的完整性限制ALTER TABLE &lt;表名&gt;[ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ][ DROP &lt;完整性约束名&gt; ][ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]； （五）域中的完整性限制断言 SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。 断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行 创建断言的语句格式 CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt; 每个断言都被赋予一个名字，&lt;CHECK 子句&gt;中的约束条件与WHERE子句的条件表达式类似。 删除断言的语句格式为 DROP ASSERTION &lt;断言名&gt;; 如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的 （六）触发器 触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程 一旦定义，任何用户对表的增、删、改操作均由服务器自动激活相应的触发器，在DBMS核心层进行集中的完整性控制 触发器可以实施比FOREIGN KEY约束、CHECK约束更为复杂的检查和操作，具有更精细和更强大的对数据完整性控制能力 1、定义触发器SQL使用CREATE TRIGGER命令建立触发器 CREATE TRIGGER &lt;触发器名&gt; {BEFORE | AFTER} &lt;触发事件&gt; ON &lt;表名&gt; [REFERENCING NEW | OLD ROW | Table AS &lt;变量&gt;] [FOR EACH {ROW | STATEMENT}] [WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;定义触发器的语法说明:①表的拥有者即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器②触发器名触发器名可以包含模式名，也可以不包含模式名同一模式下，触发器名必须是唯一的触发器名和&lt;表名&gt;必须在同一模式下③表名当这个表的数据发生变化时，将激活定义在该表上相应&lt;触发事件&gt;的触发器，该表称为触发器的目标表④触发事件触发事件可以是INSERT、DELETE或UPDATE及其组合UPDATE后面还可以有OF&lt;触发列，…&gt;，即进一步指明修改哪些列时触发器激活触发器动作时间： BEFORE：触发事件进行前，测试&lt;触发条件&gt; AFTER： 触发事件发生后，测试&lt;触发条件&gt;⑤触发器的类型：行级触发器（FOR EACH ROW）、语句级触发器⑥触发条件 触发器被激活时，只有当触发条件为真时触发动作体才执行； 否则触发动作体不执行。 如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行⑦触发动作体 可以是一个PL/SQL过程块 也可以是对已创建存储过程的调用 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化2、激活触发器 触发器的执行，是由触发事件激活的，并由数据库服务器自动执行 同一个表上的多个触发器激活时遵循如下的执行顺序： （1） 执行该表上的BEFORE触发器； （2） 激活触发器的SQL语句； （3） 执行该表上的AFTER触发器。 对于同一个表上的多个BEFORE(AFTER)触发器 有些RDBMS遵循“谁先创建谁先执行”的原则，即按照触发器创建的时间先后顺序执行 有些RDBMS按照触发器名称的字母排序顺序执行触发器 3、删除触发器 删除触发器的SQL语法： DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;; 触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。 三、事务管理与数据库恢复（一）事务的基本概念1、事务 事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务和程序是两个概念 在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序 一个程序通常包含多个事务 事务是恢复和并发控制的基本单位  COMMIT 事务正常结束 提交事务的所有操作（读+更新） 事务中所有对数据库的更新写回到磁盘上的物理数据库中 ROLLBACK 事务异常终止 事务运行的过程中发生了故障，不能继续执行 系统将事务中对数据库的所有已完成的操作全部撤销 事务滚回到开始时的状态  事务有以下3种运行模式。 自动提交事务：每条单独的语句都是一个事务。 显式事务：每个事务均以BEGIN TRANSACTION语句显式开始，以COMMIT或ROLLBACK语句显式结束。 隐性事务：在上个事务完成时新事务隐式启动，但每个事务仍以COMMIT或ROLLBACK语句显式完成。 2、事务的ACID特性： 原子性（Atomicity） 事务是数据库的逻辑工作单位 事务中包括的诸操作要么都做，要么都不做 一致性（Consistency） 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 ——一致性状态：数据库中只包含成功事务提交的结果 ——不一致状态：数据库系统运行中发生故障，有些事务尚未完成就被迫中断； 隔离性（Isolation） 一个事务的执行不能被其他事务干扰 一个事务内部的操作及使用的数据对其他并发事务是隔离的 并发执行的各个事务之间不能互相干扰 持续性（Durability ） 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。 （二）数据库恢复概述 故障是不可避免的 故障的影响①运行事务非正常中断，影响数据库中数据的正确性②破坏数据库，全部或部分丢失数据 数据库的恢复：数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能。 恢复子系统是数据库管理系统的一个重要组成部分 恢复技术是衡量系统优劣的重要指标 （三）故障的种类1.事务内部的故障 有的是可以通过事务程序本身发现的(见下面转账事务的例子) 有的是非预期的，不能由事务程序处理的。 事务故障的恢复：事务撤消（UNDO）、强行回滚（ROLLBACK）该事务 2.系统故障（软故障）①定义：是指造成系统停止运转的任何事件，使得系统要重新启动。 整个系统的正常运行突然被破坏 所有正在运行的事务都非正常终止 不破坏数据库 内存中数据库缓冲区的信息全部丢失②常见原因： 特定类型的硬件错误（如CPU故障） 操作系统故障 数据库管理系统代码错误 系统断电③恢复策略： 系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务 系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务 3.介质故障（硬故障、外存故障）常见原因：磁盘损坏、磁盘碰撞、瞬时强磁场干扰 介质故障比前两类故障的可能性小得多，但破坏性大得多 4.计算机病毒 计算机病毒的危害 有的病毒传播很快，一旦侵入系统就马上摧毁系统 有的病毒有较长的潜伏期，计算机在感染后数天或数月才开始发病 有的病毒感染系统所有的程序和数据 有的只对某些特定的程序和数据感兴趣 计算机病毒已成为计算机系统的主要威胁，自然也是数据库系统的主要威胁 数据库一旦被破坏仍要用恢复技术把数据库加以恢复 （四）恢复的实现技术——如何建立冗余数据数据转储（backup）、登记日志文件（logging）——如何利用这些冗余数据实施数据库恢复 1、数据转储（1）什么是数据转储 转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程，备用的数据文本称为后备副本或后援副本。 数据库遭到破坏后可以将后备副本重新装入 重装后备副本只能将数据库恢复到转储时的状态 要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务（2）转储方法①静态转储与动态转储 静态转储 在系统中无运行事务时进行的转储操作 转储开始时数据库处于一致性状态 转储期间不允许对数据库的任何存取、修改活动 得到的一定是一个数据一致性的副本 优点：实现简单 缺点：降低了数据库的可用性 转储必须等待正运行的用户事务结束 新的事务必须等转储结束 动态转储 转储操作与用户事务并发进行 转储期间允许对数据库进行存取或修改 优点 不用等待正在运行的用户事务结束 不会影响新事务的运行 缺点：不能保证副本中的数据正确有效②海量转储与增量转储 海量转储: 每次转储全部数据库 增量转储: 只转储上次转储后更新过的数据 海量转储与增量转储比较 从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便 如果数据库很大，事务处理又十分频繁，则增量转储方式更实用更有效 2、登记日志文件（1）日志文件的格式和内容 日志文件(log file)是用来记录事务对数据库的更新操作的文件①格式：以记录为单位： 事务标识（标明是哪个事务） 操作类型（插入、删除或修改） 操作对象（记录ID、Block NO.） 更新前数据的旧值（对插入操作而言，此项为空值） 更新后数据的新值（对删除操作而言, 此项为空值）以数据库为单位： 事务标识 被更新的数据块②内容： 各个事务的开始标记(BEGIN TRANSACTION) 各个事务的结束标记(COMMIT或ROLLBACK) 各个事务的所有更新操作（2）日志文件的作用 进行事务故障恢复 进行系统故障恢复 协助后备副本进行介质故障恢复（3）登记日志文件 为保证数据库是可恢复的，登记日志文件时必须遵循两条原则 登记的次序严格按并发事务执行的时间次序 必须先写日志文件，后写数据库 （五）恢复策略1、事务故障的恢复（1） 反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。（2） 对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。（3） 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。（4） 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。 2、系统故障的恢复（1）正向扫描日志文件（即从头扫描日志文件） 重做(REDO) 队列: 在故障发生前已经提交的事务 撤销 (UNDO)队列:故障发生时尚未完成的事务（2） 对撤销(UNDO)队列事务进行撤销(UNDO)处理 反向扫描日志文件，对每个撤销事务的更新操作执行逆操作 （3）对重做(REDO)队列事务进行重做(REDO)处理 正向扫描日志文件，对每个重做事务重新执行登记的操作3、介质故障的恢复（1）重装数据库（2）重做已完成的事务  恢复步骤（1） 装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。（2） 装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。（六）具有检查点的恢复技术1、问题的提出2、检查点技术 在日志文件中增加检查点记录（checkpoint） 增加重新开始文件 恢复子系统在登录日志文件期间动态地维护日志3、利用检查点的恢复策略（1）从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录（2）由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST（3）从检查点开始正向扫描日志文件，直到日志文件结束（4）对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作 （七）数据库镜像1、数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上。2、数据库管理系统自动保证镜像数据与主数据的一致性，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去。 出现介质故障时 可由镜像磁盘继续提供使用 同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复 不需要关闭系统和重装数据库副本没有出现故障时 可用于并发操作 一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁 四、事务的并发控制不同的多事务执行方式（1）事务串行执行（2）交叉并发方式（3）同时并发方式（一）并发控制概述1、任务 对并发操作进行正确调度 保证事务的隔离性 保证数据库的一致性并发操作带来的数据不一致性：并发操作破坏了事务的隔离性 丢失修改（Lost Update） 不可重复读（Non-repeatable Read） 读“脏”数据（Dirty Read） 记号 R(x):读数据x、W(x):写数据x（1）丢失修改 两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。（2）不可重复读 不可重复读是指事务T1读取数据后，事务T2执行更新操作（修改、删除、插入），使T1无法再现前一次读取结果。 （3）读“脏”数据 事务T1修改某一数据，并将其写回磁盘 事务T2读取同一数据后，T1由于某种原因被撤销 这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致 T2读到的数据就为“脏”数据，即不正确的数据 2、主要技术：有封锁、时间戳、乐观控制法 （二）封锁1、定义 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。2、基本封锁类型（1）排他锁（X锁、写锁）保证其他事务在T释放A上的锁之前不能再读取和修改A（2）共享锁（S锁、读锁）保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改3、锁的相容矩阵  左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。 最上面一行表示另一事务T2对同一数据对象发出的封锁请求。 T2的封锁请求能否被满足用矩阵中的Y和N表示 Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足 N表示T2的封锁请求与T1已持有的锁冲突，T2的请求被拒绝 （三）活锁和死锁1、活锁 事务T1封锁了数据R 事务T2又请求封锁R，于是T2等待。 T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。 T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……避免活锁： 当多个事务请求封锁同一数据对象时按请求封锁的先后次序对这些事务排队该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。 2、死锁 事务T1封锁了数据R1 T2封锁了数据R2 T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁 接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁 这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁避免死锁：（1）预防死锁——破坏产生死锁的条件①一次封锁法 要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 存在的问题 降低系统并发度 难于事先精确确定封锁对象②顺序封锁法 顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。 顺序封锁法存在的问题 维护成本 数据库系统中封锁的数据对象极多，并且在不断地变化。 难以实现：很难事先确定每一个事务要封锁哪些对象（2）死锁的诊断与解除①超时法 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁 优点：实现简单 缺点 有可能误判死锁 时限若设置得太长，死锁发生后不能及时发现②事务等待图法 用事务等待图动态反映所有事务的等待情况 事务等待图是一个有向图G=(T，U) T为结点的集合，每个结点表示正运行的事务 U为边的集合，每条边表示事务等待的情况 若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2 如果发现图中存在回路，则表示系统中出现了死锁。  解除死锁： 选择一个处理死锁代价最小的事务，将其撤消 释放此事务持有的所有的锁，使其它事务能继续运行下去 （四）并发调度的可串行性1、可串行化调度①可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同②可串行性 是并发事务正确调度的准则 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 2、冲突可串行性化调度（1）冲突操作：冲突操作是指不同的事务对同一个数据的读写操作和写写操作 Ri (x)与Wj(x) /* 事务Ti读x，Tj写x/ Wi(x)与Wj(x) / 事务Ti写x，Tj写x*/  可串行化调度的充分条件 一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc‘，如果Sc’是串行的，称调度Sc为冲突可串行化的调度 一个调度是冲突可串行化，一定是可串行化的调度 （五）两端锁协议 封锁协议 运用封锁方法时，对数据对象加锁时需要约定一些规则 何时申请封锁 持锁时间 何时释放封锁等 两段封锁协议(Two-Phase Locking，简称2PL)是最常用的一种封锁协议，理论上证明使用两段封锁协议产生的是可串行化调度1、两段锁协议 指所有事务必须分两个阶段对数据项加锁和解锁 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁 在释放一个封锁之后，事务不再申请和获得任何其他封锁 第一阶段是获得封锁，也称为扩展阶段 第二阶段是释放封锁，也称为收缩阶段  两段锁协议与防止死锁的一次封锁法 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁（六）封锁粒度 封锁对象的大小称为封锁粒度(Granularity) 封锁的对象：逻辑单元，物理单元 逻辑单元: 属性值、属性值集合、元组、关系、索引项、整个索引、整个数据库等 物理单元：页（数据页或索引页）、物理记录等 封锁粒度与系统的并发度和并发控制的开销密切相关。 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小； 封锁的粒度越小，并发度较高，但系统开销也就越大1、多粒度封锁（1）多粒度树 以树形结构来表示多级封锁粒度 根结点是整个数据库，表示最大的数据粒度 叶结点表示最小的数据粒度多粒度封锁协议： 允许多粒度树中的每个结点被独立地加锁 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁 在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁显式封锁: 直接加到数据对象上的封锁隐式封锁: 该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁","link":"/2020/05/26/Learning-DB-lwt/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"IEG","slug":"IEG","link":"/tags/IEG/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"面试知识点","slug":"面试知识点","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"NextEngine","slug":"NextEngine","link":"/tags/NextEngine/"},{"name":"Classified","slug":"Classified","link":"/tags/Classified/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面试经验","slug":"面试经验","link":"/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"JEngine","slug":"JEngine","link":"/tags/JEngine/"},{"name":"游戏引擎","slug":"游戏引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"CsharpWork","slug":"CsharpWork","link":"/tags/CsharpWork/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"WHU","slug":"WHU","link":"/tags/WHU/"}],"categories":[{"name":"Internship","slug":"Internship","link":"/categories/Internship/"},{"name":"Classified","slug":"Classified","link":"/categories/Classified/"},{"name":"JEngine","slug":"JEngine","link":"/categories/JEngine/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Nothing","slug":"Nothing","link":"/categories/Nothing/"},{"name":"Learning","slug":"Learning","link":"/categories/Learning/"}]}