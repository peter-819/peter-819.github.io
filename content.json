{"pages":[{"title":"Jerome's Blog","text":"从CSDN搬家到GitHub啦！CSDN博客：https://blog.csdn.net/peter_819 我是谁?武汉大学计算机学院18级本科生，2020腾讯IEG研发效能部实习生，喜欢学学图形学，游戏引擎开发。 写点啥?时不时更新，写写图形学相关，我的JEngine开发相关，实习日常相关，碎碎念相关。没事的时候挖挖坑，立立flag之类的。 联系方式QQ:172163600WeChat:ghb15004698932知乎:JeromeG邮箱:peter_819@163.com 友链Yashem: https://me.csdn.net/qq_33330876","link":"/about/index.html"}],"posts":[{"title":"Internship-Diary-3&4","text":"周末划水日记 周六看了一点点数据库的东西准备考试，一整天都没搞实习这边的事情。NE这边居然好像不用996，具体还不怎么清楚…. 周日下午看了会NE的代码，RHI的OpenGL实现这块，只是看了看buffer和一半的Pipeline。碰到几个看不懂的地方写在不发的博客里了。这个OpenGL的实现基本也就是JEngine的++++版，具体实现看的还比较清楚，只是他的架构层数太多了，需要后续理解。buffer的位置写了uniform block实现，这个我还没写过，查了查博客大概明白了。基本就是多个shader绑定几个block，然后每次get到block的index绑定数据，赋值的时候再查一下变量的offset。记得要bindbufferbase。具体的找时间写个博客记录下吧。 他们在群里也发了一遍我之前收藏的那个ECS实现，挺有意思的，一定要康康。挂一个知乎链接5.17号了都，得搞搞学校考试得东西了…头大…","link":"/2020/05/17/Internship-Diary-3-4/"},{"title":"Internship-NextEngine-RHIopengl-1","text":"??? RHIPlatformHandle? ConstBuffer bind? Dynamic VBO? Render Pass? RHI/Implement/GLES3 GLES3Buffer ConstBuffer VertexBuffer IndexBuffer GLES3ConstantBuffer 传给shader的uniform buffer 不太明白这个dynamic buffer的区别和实现 GLES3Context 还没看，应该就是设置渲染内容参数和swapbuffer GLES3Device 方法大集合 GLES3FrameBuffer 管理渲染缓存，默认是渲染到屏幕，绑定其他是离屏渲染 GLES3GpuPrograms 不知道 : TODO GLES3Pipeline 设置blend,rasterization,stencil&amp;depth参数，绘制前延迟应用设置 GLES3Program 创建，应用Program，AttachShader。 GLES3RenderPass 处理rendertarget，离屏渲染相关，实现没看懂 GLES3Sample 各种纹理采样参数设置 GLES3Shader 还没看 : TODO GLES3Texture 还没看 : TODO GLES3VBO VBO对象，绑定Vertex/Index Buffer 负责绘制等操作 dynamicVBO 不知道 : TODO GLES3Window 还没看 :TODO //总之还是各种类的OpenGL实现，实现并不难懂，但是上层抽象太多了，需要往上层看看。","link":"/2020/05/17/Internship-NextEngine-RHIopengl-1/"},{"title":"JEngine架构v1.0","text":"","link":"/2020/03/13/JEngine-Architecture-v1-0/"},{"title":"Windows API链接GLAD绘制OpenGL","text":"在使用win32 API进行编写windows窗口时，需要链接GLAD的OpenGL内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445HWND m_hwnd;HDC m_dc;HGLRC m_rc;void WinApiGLContext::Init() { PIXELFORMATDESCRIPTOR pfd = { sizeof(PIXELFORMATDESCRIPTOR), // size of this pfd 1, // version number PFD_DRAW_TO_WINDOW | // support window PFD_SUPPORT_OPENGL | // support OpenGL PFD_DOUBLEBUFFER, // double buffered PFD_TYPE_RGBA, // RGBA type 24, // 24-bit color depth 0, 0, 0, 0, 0, 0, // color bits ignored 0, // no alpha buffer 0, // shift bit ignored 0, // no accumulation buffer 0, 0, 0, 0, // accum bits ignored 32, // 32-bit z-buffer 0, // no stencil buffer 0, // no auxiliary buffer PFD_MAIN_PLANE, // main layer 0, // reserved 0, 0, 0 // layer masks ignored }; m_dc = GetDC(m_hwnd); int pf = ChoosePixelFormat(m_dc, &amp;pfd); SetPixelFormat(m_dc, pf, &amp;pfd); m_rc = wglCreateContext(m_dc); wglMakeCurrent(m_dc, m_rc); gladLoadGL(); JE_CORE_INFO(&quot;OpenGL Vendor: {0}&quot;, glGetString(GL_VENDOR)); JE_CORE_INFO(&quot;OpenGL Renderer: {0}&quot;, glGetString(GL_RENDERER)); JE_CORE_INFO(&quot;OpenGL version: {0}&quot;, glGetString(GL_VERSION));}void WinApiGLContext::SwapBuffer() { SwapBuffers(m_dc);} 注：一定要记得渲染之前设置glViewport，因为GLFW好像是默认设置viewport，我迁移到winAPI之后才发现我忘记了TAT","link":"/2020/05/04/JEngine-Win32-GLAD-tutorial/"},{"title":"C#大作业2-网络交互","text":"Abuse Of Heart 游戏网络交互模块简介 &amp; 开发须知 简介 原理 采用TCP/UDP协议传输数据包，将用户操作信号传递到服务端，服务端将物体移动信息发送给客户端 实现 初步实现了TCP/UDP数据包传输 实现了客户端登录过程：客户端connect-&gt;服务端发送welcome-&gt;客户端接受，回复welcomeReceive-&gt;服务端接受 实现了客户端操作信号发送：客户端捕获用户键盘输入发送给服务端-&gt;服务端接受信号，处理角色移动-&gt;服务端发送角色位置旋转信息-&gt;客户端接收并调用Unity接口 TODO： 需要实现投掷物——在服务端创建物体 开发须知 代码结构简介 服务端： Server：处理用户连接，为连接进来的用户分配Client逻辑（只需增减packetHandle目录） Client：TCP/UDP实现，处理数据交换（无需改动） ServerHandle：处理服务端收到的信号的函数（增添类似函数需要在Server中更改目录，Packet中改Enum） ServerSend：向客户端发送数据的函数（增添类似的函数即可发送不同数据，需要Packet中改Enum） Packet：发送的数据包类，封装了主要数据类型，以及Vector3,Quaternion（增减Handle与Send函数需要改动代码开头Enum） Constants：常量，包含每秒Tick次数，当前为30，需要与Unity中ProjectSetting相同 其他：无需更改 客户端： Client：同服务端，TCP/UDP实现，处理数据交换（需要增减packetHandle目录） ClientHandle：同服务端（增添类似函数需要在Server中更改目录） ClientSend：同服务端（packet中改Enum） Packet：同服务端（一定确保服务端与客户端代码完全一致） PlayerController：处理用户输入信号传递给服务端 GameManager：负责生成/移除对象 PlayerManager：用户信息 UIManager：登录界面UI CameraController：没有diao用 需要删除 如何开发 谁知道呢？我就写了这么多，剩下的代码注释写了一些 初步的就增加一下Handle和Send函数 所有都在服务端处理吧 代码 AOH-Client Git目录：https://code.aliyun.com/jeromeg/AOH-Client/tree/master AOH-Server Git目录：https://code.aliyun.com/jeromeg/AOH-Server/tree/master AOH-Asset Git目录： https://code.aliyun.com/jeromeg/AOH-Asset 配置 Unity相关的配置一句两句说不清，需要配置的时候在群里交流 编译 Unity 项目设置(Project Setting)中刷新时间设置成0.33333 Server端编译选项选择 Server mode 调试 本地调试时在Unity客户端的Client对象里把ip设置成127.0.0.1 服务器调试时把这个ip改成服务器的ip，保证没有防火墙屏蔽端口（可以将端口添加进防火墙）","link":"/2020/05/15/dev-UnityGame-2/"},{"title":"2020.4.15","text":"大概从2.3号开始说起吧，从打开youtube看到了那个openGL教程，从看知乎推荐下了一本《Real Time Rendering》，就开始了这两个月的故事。 明天面试腾讯和吉比特，这一周左右基本保持每天一次笔试/面试，不知道是累了还是皮了，既然不想学习就写一写记录吧。 从最开始youtube上看那个胖老哥讲opengl将近100期的教程，然后自己看RTR看了四五章，后来找到cherno的Hazel教程，跟着教程写了个框架，把胖老哥的opengl强行塞了进去玩了玩。到了三月二十看到llb问我要不要投实习，才算是一咬牙拿定了主意，一晚上投了网易互娱雷火吉比特。其实当时真的没抱希望，只是投着试试看，也没什么风险。 从20号到30号开始就搜搜面经，c++，图形学，看到什么学什么，面对面试题目学习，30号左右考了个雷火笔试，后来吉比特一直没声音，就索性多投两份，投了一个头条，投了一个完美，又过两天cbn聊的我心动了还是去投了一个腾讯日常实习。 截止到今天算是做完了所有的笔试，笔试并不难，可能只是作为筛选依据而不是标准吧。 腾讯那天突然给我发消息上午说下午电话面试，这个速度也是够快，下午打电话大概是一个意向面试吧，拿着简历问了问我的项目，问问c++基础，说我的意向非常符合他们的岗位，直接告诉我等下一轮的技术面。 至于雷火，笔试过了直接发了两次面试的时间，一面简单一点，那个老哥挺和蔼，写了个小代码，问点算法题目基础，二面老哥比较严格，不过也有点可爱，我没答上他提醒我，我接着他话说下去他说对，但是还得算你没答上哈哈。两次面试问了问我的学习方向，大概是没问题的，至于结果嘛，他说你这个基础还是不扎实，但是毕竟是相对于研究生说的，作为本科生很少有涉及这方面的。感觉是要收拒信了，等着吧。 从最开始的投着玩试试看，到后来搜面经的时候，其实已经逐渐转变想法了，一点点融入了这个过程，也更加希望自己能拿到一个offer，但是反过来看看我其实除了大二时间多一些，方向明确一些，还没什么竞争优势。这就是纠结的点吧，情感上非常想要offer，但是理性分析现实还是很残酷。 这么看起来求职这东西还是很摧残人的，回头看看这才过去两个多月，我感觉好像过了很久很久。。 希望最后最后能实现梦想吧，哪怕是秋招，明年春招，都可以。（现在说这个话还是有点丧了，毕竟希望还要有。还要继续冲） 接下去的话，大概这个月末，五一结束左右所有面试也应该差不多结束了，不管过不过，日子还得过。 这个月面试期间补一补计网和操作系统课，下个月开始补组合和数据库，然后赶紧学c#和unity，把这个大作业好好做，毕竟这也是未来的一部分。 这学期的课好好考争取能弄个3.7吧，然后闲的无聊的时候学学houdini玩。 真的是一个决定了就一条路走到南墙的人，从决定打OI开始好久没有做过这种选择了，从来没有怀疑过做这个到底是不是对的，我只觉得这就是我的以后QAQ","link":"/2020/05/03/Nothing-2020-4-15/"},{"title":"数据库系统-1","text":"数据库系统 数据库(DB) 数据库管理系统(DBMS) 数据库应用(DBAP) 数据库管理员(DBA) 计算机基本系统 数据库管理系统(DBMS) External Level Conceptual Level Internal Level 数据模型 (数据-&gt;模式-&gt;模型) 关系模型 - 表 层次模型 - 树 网状模型 - 图","link":"/2020/05/16/Learning-DB-1/"},{"title":"C#大作业1-分组","text":"UI界面+贴图素材+关卡设计 2人主要写一下进入游戏的UI系统UI可能包括：登录，创建房间，开始游戏，游戏暂停结束等关卡设计可能有：找各种贴图纹理素材，关卡的设计（要好看） 网络编程 2人主要写一下联网部分，实现一下多人在线可能要写：socket之类的网络编程，没准还得写点服务端 游戏逻辑 2人主要写人物控制，武器系统，伤害系统等等可能要写：人物控制类：操作逻辑，武器类：各种不同功能武器，伤害系统：伤害计算 分数计算后续可能写点机关？","link":"/2020/05/07/dev-UnityGame-1/"},{"title":"图形学面试知识点","text":"图形学面试知识点 图形学 渲染管线顶点数据输入 (Vertices)顶点着色器 (Vertex Shader)曲面细分着色器 (Tessellation Shader)几何着色器 (Geometry Shader)图元装配 (Primitive Setup)裁剪剔除 (Culling and Clipping)屏幕映射 (Screen Mapping)光栅化 (Rasterization)片段着色器 (Fragment Shader)混合测试 (Blending and Testing) 顶点数据顶点坐标，顶点纹理，顶点法线，顶点颜色等顶点缓存(Vertex Buffer)，索引缓存 (Index Buffer) 顶点着色器输入顶点数据 坐标变换：(*为顶点着色器中) 局部坐标 (Local Coor)| 模型矩阵 Model *世界坐标 (World Coor)| 观察矩阵View *观察坐标 (View Coor)| 投影矩阵Projection *裁剪坐标 (Clip Coor)| 透视除法标准设备空间 NDC (Normalized Device Coor)| 视口变换窗口坐标 + 法线变换 * 平移不变，旋转乘渲染矩阵，非均匀缩放 （矩阵逆变换） + 投影 * 透视投影 (Projective Projection) : 视锥体 (Frustum): znear,zfar,视角FOV(Field of View),屏幕纵横比(Aspect Ratio) * 正交投影 (Orthographic Projection) : 正方体 + 着色 * 平面着色 (Flat Shading) : 三角形第一个点标识颜色 * 高洛德着色 (Gouraud Shader) : 顶点着色器中计算顶点颜色，光栅化插值颜色 * 冯氏着色 (Phong Shading) : 光栅化插值法线，片元着色器中计算颜色 曲面细分着色器 (Tessellation Shader) 几何着色器 (Geometry Shader) 图元装配 向顶点装入DrawCall指定的图元 裁剪 背面剔除删除背对摄像机的图元，法向量判断，三点顺时针剔除，逆时针保留（右手定则）可以设置剔除方向back/front 屏幕映射 (Screen Mapping) 透视除法：点坐标为齐次坐标，经过透视矩阵变换后w值不为1，将xyz除以w以达到近大远小 视口变换：将NDC坐标转换为窗口坐标，将z坐标映射到[-1,1]（OpenGL）， glViewport() 设定视口坐标&amp;宽高 拾取 光栅化 线段光栅化： 数字微分画线 DDA(Digital Differential Analyzer) : 取增量x判断y，有浮点运算 Bresenham ：没有浮点数运算，d = Δx(b-a) 判断d 片段着色器 (Fragment Shader) 光照模型 Phong : 计算高光：光源向量关于法线反射向量计算（不连续，大于90度为负） Blinn-Phone：计算高光：光源向量+视角向量计算 （连续） 纹理 法线贴图 锯齿和抗锯齿 (Aliasing and Anti-aliasing) 阴影 阴影贴图 测试 裁切测试 Alpha测试 深度测试 模板测试 混合 Alpha混合 场景管理 BSP树 四叉树八叉树 k-d树 延迟渲染 前向渲染 (defer / forward) 延迟渲染优点：对于多光源场景效率更优 延迟渲染缺点：不能用硬件抗锯齿，不能渲染透明体，GPU带宽占用高（手游不常用） 实现方法：前向渲染中光照在fragment shader中计算，延迟渲染将光照只在最后显示出的像素上计算，将原来计算光照的数据如法线，颜色，坐标，高光等存入G-buffer，在进行z-test后另行渲染光照，对每个最终显示的像素计算光照信息。 OpenGL实现 纹理 纹理环绕 GL_REPEAT ：重复 GL_MIRRORED_REPEAT ：镜像重复 GL_CLAMP_TO_EDGE ：边缘拉伸 GL_CLAMP_TO_BORDER ：边缘指定颜色 纹理过滤：将纹理坐标浮点值映射到像素 GL_NEAREST ：取最近邻的像素颜色 GL_LINEAR ：根据相邻像素颜色插值 MipMap","link":"/2020/05/03/Internship-CG/"},{"title":"Internship-Diary-1","text":"实习日记Day1 5.14 上午一直在等邮件发pin密码什么的，但是一直也没有邮件。问了一下群友，群友说直接打电话给8000激活token就可以。8000小哥直接给我激活了之后发了我pin，然后一通激活各种设备软件。 Leader先拉我进了组微信群，群友一看00后的我都呆了哈哈哈然后配了一下远程桌面，连到公司的台式机工作。 pull了一下engine的代码，打算编译，结果因为公司内网给的IDE版本不是最新，耽误了我一下午的时间编译错误。。。晚上看了看render部分的文档就完事了 这个引擎实现还不算很完善，但是好像已经可以做到对接QQ程序，具体还要看看细节。渲染模块除了RHI抽象 还继续抽象了一层，什么renderPass那一块没有太看明白。 哦对了 今天上午UE5官方放出来了介绍视频，明年发布，群友后来热烈讨论了一番技术实现，听的我一头雾水，然后zxx大佬晚上就放出了一篇知乎大概介绍了一下大概的理解大概放几个名词后续查一下LOD软光栅化还有Tessellation一些细节","link":"/2020/05/15/Internship-Diary-1/"},{"title":"Internship-Diary-2","text":"实习日记Day2 5.15 上午开了个组会，先是跟QQ那边一起，做一个简单的周工作汇报然后是NE这边，新拉进来了一个网易大佬，我这远程入职还是很没有存在感 jiang同学做了一下Engine Editor的介绍讲了一下发展历史，功能区别，放了五个阶段，指出了一下进化的几个点，他提到说Editor大概可以类比于IDE，Script也可以算作Editor的一部分，然后展示了一下自己之前做的一个Demo，那个demo我看起来已经实现了大部分引擎的基本操作了。着实nb 下午跟mentor说我编译好了，接下去他说要我看一下文档自己操作一下Editor，然后看一下RHI里GL部分的实现。感觉这个GL实现应该和我的抽象结构差不多，只是RHI的抽象功能多得多，要好好看个几天吧。 后来就划了划水，看他们还在讨论UE5的事情。诶，原来我们组有一大半的人base杭州啊，有点意思。 感觉接下去一段时间都要去看这个RHI实现代码了，想在这几个月搞清楚这个引擎的架构，感觉蛮有意思~","link":"/2020/05/15/Internship-Diary-2/"},{"title":"C++面试知识点","text":"C++面试知识点 C++ const修饰指针const int* p不可改变指针值int* const p不可改变p指向修饰引用：const string&amp; str修饰成员函数void func() const {} 不可改变成员变量（const ClassName *this） static修饰全局变量&amp;函数：限定在当前编译单元修饰局部变量：开在静态区，只初始化一次，可用域为当前范围修饰成员函数：不可访问非静态成员，只能用类名调用，没有this修饰成员变量：只能类名调用，在静态区。在main函数执行之前分配内存。 inline复制函数代码调用函数不压栈，直接映射参数&amp;返回值类声明中函数都是inline建议编译器inline，有循环递归switch的不inline乱用会代码膨胀，且修改后重新编译所有调用虚函数可以内联但是失去运行时多态，只能className a;a.test(); this非静态函数中，指向调用它的对象，不可赋值（ClassName* const this）属于非静态成员函数默认第一个参数，可以std::bind volatile编译器会自动优化如int a = 2;b=a+2;cout&lt;&lt;b;不将a写入内存直接当作2调用。如果在b=a+2;前 a被其他线程或某种原因修改则出错声明后禁止编译器编译优化，强制写入读出内存。可以修饰指针 const sizeof数组sizeof为数组空间大小指针sizeof为指针本身大小（一半为4） 内存对齐结构体中存在内存对齐，假设pragma pack设定值为p当前类型大小为q为当前变量开空间时遵循开头位置offset被min(p,q)整除总开辟空间遵循可以被max({q},p)整除如int a;char b;char c;占用8char a;int b;char c;占用12#prama pack()可以设置为1,2,4,8等位域：限制某类型变量只占用若干二进制位，int a:2; a只占用两个bit extern可以在其他编译单元使用，可以代替部分include的工作。extern “C”{ … } 在c++中调用c风格代码 explicit修饰构造函数或转换函数（重载括号运算）可以防止隐式转换 如ClassName c = 1;会隐式调用构造函数ClassName(int)(参数只有一个或其余均有默认值)explicit声明后只能显示ClassName c = ClassName(1); friend可以访问private，且单向。 usingusing namespace / using namespace::nameC++11中派生类using base::base;可以重用父类构造函数相当于derived(params) : base(args){}还可以相当于typedef 给模板别名template&lt; typename T&gt;using Ref = std::share_ptr&lt; T&gt;; decltype检查实体声明类型并使用int a;decltype(a) 为int 可以直接声明变量可以后置声明返回值类型template&lt; typename IT&gt;auto fcn(IT a) -&gt; decltype(a){} 左右值引用右值引用：字符串常量，临时对象等等移动语义：move() 传入左/右值 返回右值引用原理：引用折叠：除了&amp;&amp;+&amp;&amp;=&amp;&amp;其他均为&amp;传入模板函数中的左值T自带一个&amp;精确传递：解决传入函数参数推测类型默认为左值问题 描述不太清楚 define一对一转换参数#define test(type) #type ：将type字面转为字符串##：连接两个字面值 多态编译期多态：函数&amp;运算符重载 ， 模板运行期多态：虚函数， 类型转换（dynamic_cast）RTTI 虚函数虚函数表：生成对象时产生，继承时继承父类虚函数表指针有虚函数的空类大小为4(vfptr) 无虚函数空类大小为1重写时覆盖虚函数表的函数指针构造函数不能虚函数：调用构造函数时没有虚表指针虚析构函数：被继承时一定虚析构，防止泄露纯虚函数：抽象类 虚继承/多继承防止菱形继承内存重复，采用虚表，继承时继承多个父类的虚表指针虚表存储虚基类内存偏移量 描述不清 内存分配new/delete:自动调用构造/析构函数，在堆区开内存，失败返回badalloc定位new new(p) int(2);在p指针位置开内存 其实就是返回int类型的pmalloc/free:不调用构造/析构，失败返回null，开内存位置不同于new *不清楚**对象内存限制：只能开在堆上：私有析构函数（在栈中开时会检测构造/析构函数）只能开在栈上：私有重载new&amp;delete 智能指针shared_ptr: 可以多个指向同一对象，有引用计数，计数归零析构对象delete 实现unique_ptr: 不可以多个指向同一对象，不可以赋值，可以右值赋值（move）赋值后销除原指针weak_ptr: 解决share_ptr死锁问题：两个资源相互引用，无法同时析构。相当于shared_ptr的容器，不增加引用计数，通过lock获得原share指针auto_ptr:可以赋值操作的unique 原标准中，C++11弃用 类型转换const_cast: 可以删除原对象const/volatile属性reinterpret_cast: 重新解释二进制数据，最强制转换，慎用static_cast: 基本同c中显式转换，可以父类-&gt;子类 （不安全）dynamic_cast: RTTI 运行时类型信息，可以父类转子类自动检测是否可以转换（仅支持有虚函数表的类） RTTI相关typeid 返回type_info 运行时对象类型type_info对象中保存的类型信息 lambda表达式[=]：接受所有值，按值[&amp;]：接受所有值，按引用[a]：接受a，按值[&amp;a]：接受a，按引用[&amp;,a]：接受a按值，接受其他所有按引用[=,&amp;a]：接受a按引用，接受其他所有按值[a] ( ) mutable {a++;} 按值接受a拷贝 修改a拷贝a值不变[ ] ( )-&gt;int{return 1;} 返回值类型int 链接库 静态链接：浪费内存空间，每个可执行程序对目标文件都要副本，一个模块更新需要重新编译。 动态链接：将对符号的重定位推迟到运行时，解决静态库的两个缺点。","link":"/2020/05/03/Internship-CPP/"},{"title":"Internship-Diary-5","text":"实习日记Day5 5.18 又是一个周一，早上起来差点错过组会。他们交流了一下这周需要做的事情，cue了我一下，我主要还是熟悉项目。mentor发微信说要我熟悉一下pipeline实现和Pipeline State Object (PSO)看了一下，大概的理解就是PSO是管线状态集，blending/rasterization/stencil&amp;depth的参数合集，然后GLES3Pipeline实现了一下把状态传递给gl，这里还是延迟传递，在draw之前才传参数 不知道是不是正确理解，然后又继续去看gl实现了，GL的实现看起来不算困难，主要就是抽象层数太多，比较细致，不是很容易读懂，而且我还没有搞清楚上层绘制的流程是怎么样的，感觉实现的这些类都有重叠的功能。 早晨起来开始工作也基本十点多十一点了，到下午3点左右吃顿饭，5点不到就出去划水了，晚上就更没心情工作了。。。还是要早睡早起，而且多点工作时间了，毕竟还要准备考试。。。挺过去就好了，好想去深圳啊，感觉他们挺欢乐得，还不用加班（猜的） 哦下午闲的没事翻moa里的项目组，发现IEG的引擎组还是挺多的~之前都没了解","link":"/2020/05/18/Internship-Diary-5/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"IEG","slug":"IEG","link":"/tags/IEG/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"面试知识点","slug":"面试知识点","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"NextEngine","slug":"NextEngine","link":"/tags/NextEngine/"},{"name":"Classified","slug":"Classified","link":"/tags/Classified/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面试经验","slug":"面试经验","link":"/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"JEngine","slug":"JEngine","link":"/tags/JEngine/"},{"name":"游戏引擎","slug":"游戏引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"CsharpWork","slug":"CsharpWork","link":"/tags/CsharpWork/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"WHU","slug":"WHU","link":"/tags/WHU/"}],"categories":[{"name":"Internship","slug":"Internship","link":"/categories/Internship/"},{"name":"Classified","slug":"Classified","link":"/categories/Classified/"},{"name":"JEngine","slug":"JEngine","link":"/categories/JEngine/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Nothing","slug":"Nothing","link":"/categories/Nothing/"},{"name":"Learning","slug":"Learning","link":"/categories/Learning/"}]}