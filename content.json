{"pages":[{"title":"Jerome's Blog","text":"从CSDN搬家到GitHub啦！CSDN博客：https://blog.csdn.net/peter_819 我是谁?武汉大学计算机学院18级本科生，2020腾讯IEG研发效能部实习生，喜欢学学图形学，游戏引擎开发。 写点啥?时不时更新，写写图形学相关，我的JEngine开发相关，实习日常相关，碎碎念相关。没事的时候挖挖坑，立立flag之类的。 联系方式QQ:172163600WeChat:ghb15004698932知乎:JeromeG邮箱:peter_819@163.com 友链Yashem: https://me.csdn.net/qq_33330876","link":"/about/index.html"}],"posts":[{"title":"C++面试知识点","text":"C++面试知识点 C++ const修饰指针const int* p不可改变指针值int* const p不可改变p指向修饰引用：const string&amp; str修饰成员函数void func() const {} 不可改变成员变量（const ClassName *this） static修饰全局变量&amp;函数：限定在当前编译单元修饰局部变量：开在静态区，只初始化一次，可用域为当前范围修饰成员函数：不可访问非静态成员，只能用类名调用，没有this修饰成员变量：只能类名调用，在静态区。在main函数执行之前分配内存。 inline复制函数代码调用函数不压栈，直接映射参数&amp;返回值类声明中函数都是inline建议编译器inline，有循环递归switch的不inline乱用会代码膨胀，且修改后重新编译所有调用虚函数可以内联但是失去运行时多态，只能className a;a.test(); this非静态函数中，指向调用它的对象，不可赋值（ClassName* const this）属于非静态成员函数默认第一个参数，可以std::bind volatile编译器会自动优化如int a = 2;b=a+2;cout&lt;&lt;b;不将a写入内存直接当作2调用。如果在b=a+2;前 a被其他线程或某种原因修改则出错声明后禁止编译器编译优化，强制写入读出内存。可以修饰指针 const sizeof数组sizeof为数组空间大小指针sizeof为指针本身大小（一半为4） 内存对齐结构体中存在内存对齐，假设pragma pack设定值为p当前类型大小为q为当前变量开空间时遵循开头位置offset被min(p,q)整除总开辟空间遵循可以被max({q},p)整除如int a;char b;char c;占用8char a;int b;char c;占用12#prama pack()可以设置为1,2,4,8等位域：限制某类型变量只占用若干二进制位，int a:2; a只占用两个bit extern可以在其他编译单元使用，可以代替部分include的工作。extern “C”{ … } 在c++中调用c风格代码 explicit修饰构造函数或转换函数（重载括号运算）可以防止隐式转换 如ClassName c = 1;会隐式调用构造函数ClassName(int)(参数只有一个或其余均有默认值)explicit声明后只能显示ClassName c = ClassName(1); friend可以访问private，且单向。 usingusing namespace / using namespace::nameC++11中派生类using base::base;可以重用父类构造函数相当于derived(params) : base(args){}还可以相当于typedef 给模板别名template&lt; typename T&gt;using Ref = std::share_ptr&lt; T&gt;; decltype检查实体声明类型并使用int a;decltype(a) 为int 可以直接声明变量可以后置声明返回值类型template&lt; typename IT&gt;auto fcn(IT a) -&gt; decltype(a){} 左右值引用右值引用：字符串常量，临时对象等等移动语义：move() 传入左/右值 返回右值引用原理：引用折叠：除了&amp;&amp;+&amp;&amp;=&amp;&amp;其他均为&amp;传入模板函数中的左值T自带一个&amp;精确传递：解决传入函数参数推测类型默认为左值问题 描述不太清楚 define一对一转换参数#define test(type) #type ：将type字面转为字符串##：连接两个字面值 多态编译期多态：函数&amp;运算符重载 ， 模板运行期多态：虚函数， 类型转换（dynamic_cast）RTTI 虚函数虚函数表：生成对象时产生，继承时继承父类虚函数表指针有虚函数的空类大小为4(vfptr) 无虚函数空类大小为1重写时覆盖虚函数表的函数指针构造函数不能虚函数：调用构造函数时没有虚表指针虚析构函数：被继承时一定虚析构，防止泄露纯虚函数：抽象类 虚继承/多继承防止菱形继承内存重复，采用虚表，继承时继承多个父类的虚表指针虚表存储虚基类内存偏移量 描述不清 内存分配new/delete:自动调用构造/析构函数，在堆区开内存，失败返回badalloc定位new new(p) int(2);在p指针位置开内存 其实就是返回int类型的pmalloc/free:不调用构造/析构，失败返回null，开内存位置不同于new *不清楚**对象内存限制：只能开在堆上：私有析构函数（在栈中开时会检测构造/析构函数）只能开在栈上：私有重载new&amp;delete 智能指针shared_ptr: 可以多个指向同一对象，有引用计数，计数归零析构对象delete 实现unique_ptr: 不可以多个指向同一对象，不可以赋值，可以右值赋值（move）赋值后销除原指针weak_ptr: 解决share_ptr死锁问题：两个资源相互引用，无法同时析构。相当于shared_ptr的容器，不增加引用计数，通过lock获得原share指针auto_ptr:可以赋值操作的unique 原标准中，C++11弃用 类型转换const_cast: 可以删除原对象const/volatile属性reinterpret_cast: 重新解释二进制数据，最强制转换，慎用static_cast: 基本同c中显式转换，可以父类-&gt;子类 （不安全）dynamic_cast: RTTI 运行时类型信息，可以父类转子类自动检测是否可以转换（仅支持有虚函数表的类） RTTI相关typeid 返回type_info 运行时对象类型type_info对象中保存的类型信息 lambda表达式[=]：接受所有值，按值[&amp;]：接受所有值，按引用[a]：接受a，按值[&amp;a]：接受a，按引用[&amp;,a]：接受a按值，接受其他所有按引用[=,&amp;a]：接受a按引用，接受其他所有按值[a] ( ) mutable {a++;} 按值接受a拷贝 修改a拷贝a值不变[ ] ( )-&gt;int{return 1;} 返回值类型int 链接库 静态链接：浪费内存空间，每个可执行程序对目标文件都要副本，一个模块更新需要重新编译。 动态链接：将对符号的重定位推迟到运行时，解决静态库的两个缺点。","link":"/2020/05/03/Intership-CPP/"},{"title":"图形学面试知识点","text":"图形学面试知识点 图形学 渲染管线顶点数据输入 (Vertices)顶点着色器 (Vertex Shader)曲面细分着色器 (Tessellation Shader)几何着色器 (Geometry Shader)图元装配 (Primitive Setup)裁剪剔除 (Culling and Clipping)屏幕映射 (Screen Mapping)光栅化 (Rasterization)片段着色器 (Fragment Shader)混合测试 (Blending and Testing) 顶点数据顶点坐标，顶点纹理，顶点法线，顶点颜色等顶点缓存(Vertex Buffer)，索引缓存 (Index Buffer) 顶点着色器输入顶点数据 坐标变换：(*为顶点着色器中) 局部坐标 (Local Coor)| 模型矩阵 Model *世界坐标 (World Coor)| 观察矩阵View *观察坐标 (View Coor)| 投影矩阵Projection *裁剪坐标 (Clip Coor)| 透视除法标准设备空间 NDC (Normalized Device Coor)| 视口变换窗口坐标 + 法线变换 * 平移不变，旋转乘渲染矩阵，非均匀缩放 （矩阵逆变换） + 投影 * 透视投影 (Projective Projection) : 视锥体 (Frustum): znear,zfar,视角FOV(Field of View),屏幕纵横比(Aspect Ratio) * 正交投影 (Orthographic Projection) : 正方体 + 着色 * 平面着色 (Flat Shading) : 三角形第一个点标识颜色 * 高洛德着色 (Gouraud Shader) : 顶点着色器中计算顶点颜色，光栅化插值颜色 * 冯氏着色 (Phong Shading) : 光栅化插值法线，片元着色器中计算颜色 曲面细分着色器 (Tessellation Shader) 几何着色器 (Geometry Shader) 图元装配 向顶点装入DrawCall指定的图元 裁剪 背面剔除删除背对摄像机的图元，法向量判断，三点顺时针剔除，逆时针保留（右手定则）可以设置剔除方向back/front 屏幕映射 (Screen Mapping) 透视除法：点坐标为齐次坐标，经过透视矩阵变换后w值不为1，将xyz除以w以达到近大远小 视口变换：将NDC坐标转换为窗口坐标，将z坐标映射到[-1,1]（OpenGL）， glViewport() 设定视口坐标&amp;宽高 拾取 光栅化 线段光栅化： 数字微分画线 DDA(Digital Differential Analyzer) : 取增量x判断y，有浮点运算 Bresenham ：没有浮点数运算，d = Δx(b-a) 判断d 片段着色器 (Fragment Shader) 光照模型 Phong : 计算高光：光源向量关于法线反射向量计算（不连续，大于90度为负） Blinn-Phone：计算高光：光源向量+视角向量计算 （连续） 纹理 法线贴图 锯齿和抗锯齿 (Aliasing and Anti-aliasing) 阴影 阴影贴图 测试 裁切测试 Alpha测试 深度测试 模板测试 混合 Alpha混合 场景管理 BSP树 四叉树八叉树 k-d树 延迟渲染 前向渲染 (defer / forward) 延迟渲染优点：对于多光源场景效率更优 延迟渲染缺点：不能用硬件抗锯齿，不能渲染透明体，GPU带宽占用高（手游不常用） 实现方法：前向渲染中光照在fragment shader中计算，延迟渲染将光照只在最后显示出的像素上计算，将原来计算光照的数据如法线，颜色，坐标，高光等存入G-buffer，在进行z-test后另行渲染光照，对每个最终显示的像素计算光照信息。 OpenGL实现 纹理 纹理环绕 GL_REPEAT ：重复 GL_MIRRORED_REPEAT ：镜像重复 GL_CLAMP_TO_EDGE ：边缘拉伸 GL_CLAMP_TO_BORDER ：边缘指定颜色 纹理过滤：将纹理坐标浮点值映射到像素 GL_NEAREST ：取最近邻的像素颜色 GL_LINEAR ：根据相邻像素颜色插值 MipMap","link":"/2020/05/03/Intership-CG/"},{"title":"2020.4.15","text":"大概从2.3号开始说起吧，从打开youtube看到了那个openGL教程，从看知乎推荐下了一本《Real Time Rendering》，就开始了这两个月的故事。 明天面试腾讯和吉比特，这一周左右基本保持每天一次笔试/面试，不知道是累了还是皮了，既然不想学习就写一写记录吧。 从最开始youtube上看那个胖老哥讲opengl将近100期的教程，然后自己看RTR看了四五章，后来找到cherno的Hazel教程，跟着教程写了个框架，把胖老哥的opengl强行塞了进去玩了玩。到了三月二十看到llb问我要不要投实习，才算是一咬牙拿定了主意，一晚上投了网易互娱雷火吉比特。其实当时真的没抱希望，只是投着试试看，也没什么风险。 从20号到30号开始就搜搜面经，c++，图形学，看到什么学什么，面对面试题目学习，30号左右考了个雷火笔试，后来吉比特一直没声音，就索性多投两份，投了一个头条，投了一个完美，又过两天cbn聊的我心动了还是去投了一个腾讯日常实习。 截止到今天算是做完了所有的笔试，笔试并不难，可能只是作为筛选依据而不是标准吧。 腾讯那天突然给我发消息上午说下午电话面试，这个速度也是够快，下午打电话大概是一个意向面试吧，拿着简历问了问我的项目，问问c++基础，说我的意向非常符合他们的岗位，直接告诉我等下一轮的技术面。 至于雷火，笔试过了直接发了两次面试的时间，一面简单一点，那个老哥挺和蔼，写了个小代码，问点算法题目基础，二面老哥比较严格，不过也有点可爱，我没答上他提醒我，我接着他话说下去他说对，但是还得算你没答上哈哈。两次面试问了问我的学习方向，大概是没问题的，至于结果嘛，他说你这个基础还是不扎实，但是毕竟是相对于研究生说的，作为本科生很少有涉及这方面的。感觉是要收拒信了，等着吧。 从最开始的投着玩试试看，到后来搜面经的时候，其实已经逐渐转变想法了，一点点融入了这个过程，也更加希望自己能拿到一个offer，但是反过来看看我其实除了大二时间多一些，方向明确一些，还没什么竞争优势。这就是纠结的点吧，情感上非常想要offer，但是理性分析现实还是很残酷。 这么看起来求职这东西还是很摧残人的，回头看看这才过去两个多月，我感觉好像过了很久很久。。 希望最后最后能实现梦想吧，哪怕是秋招，明年春招，都可以。（现在说这个话还是有点丧了，毕竟希望还要有。还要继续冲） 接下去的话，大概这个月末，五一结束左右所有面试也应该差不多结束了，不管过不过，日子还得过。 这个月面试期间补一补计网和操作系统课，下个月开始补组合和数据库，然后赶紧学c#和unity，把这个大作业好好做，毕竟这也是未来的一部分。 这学期的课好好考争取能弄个3.7吧，然后闲的无聊的时候学学houdini玩。 真的是一个决定了就一条路走到南墙的人，从决定打OI开始好久没有做过这种选择了，从来没有怀疑过做这个到底是不是对的，我只觉得这就是我的以后QAQ","link":"/2020/05/03/Nothing-2020-4-15/"},{"title":"JEngine架构v1.0","text":"","link":"/2020/03/13/JEngine-Architecture-v1-0/"}],"tags":[{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"面试经验","slug":"面试经验","link":"/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"},{"name":"面试知识点","slug":"面试知识点","link":"/tags/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"JEngine","slug":"JEngine","link":"/tags/JEngine/"},{"name":"游戏引擎","slug":"游戏引擎","link":"/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}],"categories":[{"name":"Internship","slug":"Internship","link":"/categories/Internship/"},{"name":"Nothing","slug":"Nothing","link":"/categories/Nothing/"},{"name":"JEngine","slug":"JEngine","link":"/categories/JEngine/"}]}